
;;; 65C02 disassembler
;;;
;;; to be incorporated into the monitor eventually, but for now
;;; written as a separate program.
;;;
;;; paul dourish, october 2017
;;;

#include "decl.a65"

;;;
;;; i'm following details and logic from
;;; http://www.llx.com/~nparker/a2/opcodes.html
;;;
;;; most instructions are of the form aaabbbcc, where cc signals
;;; a block of instructons that operate in a similar way, with aaa
;;; indicating the instructoon and bbb indicating the addressing mode.
;;;

SCRATCH=$0010       ; through $001F
BASE=$0050          ; and $0051

setup
  phx               ; preserve X (it's a stack pointer elsewhere)
  lda #<testcode    ; load testcode as our BASE for disassembly
  sta BASE
  lda #>testcode
  sta BASE+1
  ldy #0            ; y will track bytes as we go

start
  lda (BASE),y      ; get the instruction
  and #%00000011    ; look at the "cc" bits -- what sort of opcode?
  beq branch00      ; go to branch for cc=00
  cmp #%00000010
  beq branch10      ; go to branch for cc=10
  cmp #%00000001
  bne others        ; go to branch for remaining opcodes

;;; interpret according to the pattern for cc=01
;;;
branch01
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2, ...
  lsr               ; ... the better to use as index into opcode table
  tax
  ; so now cc01table,x is the pointer to the right string
  lda cc01table,x
  sta SCRATCH
  lda cc01table+1,x
  sta SCRATCH+1
  ; print the three characters pointed to there
  ldx #0
  lda (SCRATCH),x   ; first character...
  jsr puta          ; print it
  inx
  lda (SCRATCH),x   ; second character...
  jsr puta          ; print it
  inx
  lda (SCRATCH),x   ; third character...
  jsr puta          ; print it
  lda #$20          ; print a space
  jsr puta
  
  ;;; handle each addressing mode
  ;;; the addressing mode is going to determine how many
  ;;; bytes we need to consume overall
  lda (BASE),y      ; get the instruction again
  and #%00011100    ; extract the bbb bits -- addressing mode
  beq indzpx        ; indirect zero page,x
  cmp #%00000100
  beq zp            ; zero page
  cmp #%00001000
  beq imm           ; immediate
  cmp #%00001100
  beq abs
  cmp #%00010000
  beq izpy
  cmp #%00010100
  beq absy
absx
  ;; absolute, X -- consumes two more bytes
  iny               ; get the second (most-sig) byte first
  iny
  lda (BASE),y
  jsr putax
  dey               ; then the less-significant byte
  lda (BASE),y
  jsr putax
  iny
  lda #',
  jsr puta
  lda #'X
  jsr puta
  iny               ; leave Y pointing to last byte consumed
  jmp endline
indzpx
  ;; (zero page,X) -- consumes one more byte
zp
  ;; zero page -- consumes one more byte
imm
  ;; immediate -- consumes one more byte
abs
  ;; absolute -- consumes two more bytes
izpy
  ;; (zero page),Y -- consumes one more byte
zpx
  ;; zero page,X -- consumes one more byte
absy
  ;; absolute,Y -- consumes two more bytes


  ;;
;;; cc=10?
branch10
;;; look up opcode

;;; handle each addressing mode

;;; special cases for STX and LDX

;; cc = 00?
branch00

;;; look up opcode

;;; handle each addressing mode (NOTE same as cc=10)


;;; branch instructions -- actually, these don't follow pattern so do FIRST
others
;;; branches have the form xxy10000
;;; xxy*2 should index into branchtable
;;; remaining special cases?

endline
  jsr crlf
  rts



cc01table
  .word ORAstr, ANDstr, EORstr, ADCstr, STAstr, LDAstr, CMPstr, SBCstr

cc10table
  .word ASLstr, ROLstr, LSRstr, RORstr, STXstr, LDXstr, DECstr, INCstr

cc00table
  .word NONstr, BITstr, JMPstr, JMPstr, STYstr, LDYstr, CPYstr, CPXstr

branchtable
  .word BPLstr, BMIstr, BVCstr, BVSstr, BCCstr, BCSstr, BNEstr, BEQstr

ORAstr .byte "ORA"
ANDstr .byte "AND"
EORstr .byte "EOR"
ADCstr .byte "ADC"
STAstr .byte "STA"
LDAstr .byte "LDA"
CMPstr .byte "CMP"
SBCstr .byte "SBC"
ASLstr .byte "ASL"
ROLstr .byte "ROL"
LSRstr .byte "LSR"
RORstr .byte "ROR"
STXstr .byte "STX"
LDXstr .byte "LDX"
DECstr .byte "DEC"
INCstr .byte "INC"
NONstr .byte "???"
BITstr .byte "BIT"
JMPstr .byte "JMP"
STYstr .byte "STY"
LDYstr .byte "LDY"
CPYstr .byte "CPY"
CPXstr .byte "CPX"
BPLstr .byte "BPL"
BMIstr .byte "BMI"
BVCstr .byte "BVC"
BVSstr .byte "BVS"
BCCstr .byte "BCC"
BCSstr .byte "BCS"
BNEstr .byte "BNE"
BEQstr .byte "BEQ"


puta
.(
  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts

;;;
;;; output the value in the accumulator as a hex pattern
;;; NB x cannot be guaranteed to be stack ptr during this... check...
;;;
putax
.(
  phy

  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  pha             ; put a copy back
  clc
  and #$f0
  ror
  ror
  ror
  ror
  tay
  lda hextable,y
  sta ACIA_DATA
wait_txd_empty2
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty2
  pla
  clc
  and #$0f
  tay
  lda hextable,y
  sta ACIA_DATA
.)
  ply
  rts

crlf
  pha
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0d
  sta ACIA_DATA
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0a
  sta ACIA_DATA
  pla
  rts

hextable:        .byte "0123456789ABCDEF"


;;; this code makes no sense; it's here purely for test purposes
;;; as a disassembler target
testcode
  lda 1234,x  
  ldx #0
  lda #$66
  sta ($04),x
  bne next
  inx
next
  ora $4044
  cmp #$ff
  adc ($77,y)
  rts
