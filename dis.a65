
;;; 65C02 disassembler
;;; to be incorporated into the monitor eventually, but for now
;;; written as a separate program.
;;;
;;; paul dourish, october 2017
;;;


;;;
;;; i'm following details and logic from
;;; http://www.llx.com/~nparker/a2/opcodes.html
;;;

;;; bottom two bits of instruction byte signal a block of instructions
;;; with differnt encoding patterns. so, start there.

  lda (BASE),y
  and #%00000011
  beq branch00      ; go to branch for cc=00
  cmp #%00000010
  beq branch10      ; go to brnach for cc=10
  cmp #%00000001
  bne others        ; go to branch for remaining opcodes
branch01
;;; cc=01?
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2
  lsr               ; the better to use as an index into opcode table
  tax
  ; so now cc01table,x is the pointer to the right string



;;; handle each addressing mode

;;; cc=10?
branch10
;;; look up opcode

;;; handle each addressing mode

;;; special cases for STX and LDX

;; cc = 00?
branch00

;;; look up opcode

;;; handle each addressing mode (NOTE same as cc=10)


;;; branch instructions -- actually, these don't follow pattern so do FIRST
others

;;; remaining special cases?





cc01table
  .word ORAstr, ANDstr, EORstr, ADCstr, STAstr, LDAstr, CMPstr, SBCstr

cc10table
  .word ASLstr, ROLstr, LSRstr, RORstr, STXstr, LDXstr, DECstr, INCstr

cc00table
  .word NONstr, BITstr, JMPstr, JMPstr, STYstr, LDYstr, CPYstr, CPXstr


ORAstr .byte "ORA"
ANDstr .byte "AND"
EORstr .byte "EOR"
ADCstr .byte "ADC"
STAstr .byte "STA"
LDAstr .byte "LDA"
CMPstr .byte "CMP"
SBCstr .byte "SBC"
ASLstr .byte "ASL"
ROLstr .byte "ROL"
LSRstr .byte "LSR"
RORstr .byte "ROR"
STXstr .byte "STX"
LDXstr .byte "LDX"
DECstr .byte "DEC"
INCstr .byte "INC"
NONstr .byte "???"
BITstr .byte "BIT"
JMPstr .byte "JMP"
STYstr .byte "STY"
LDYstr .byte "LDY"
CPYstr .byte "CPY"
CPXstr .byte "CPX"


;;; this code makes no sense; it's here purely for test purposes
;;; as a disassembler target
testcode
  ldx #0
  lda #$66
  sta ($04),x
  bne next
  inx
next
  ora $4044
  cmp #ff
  adc ($77,y)
  rts
