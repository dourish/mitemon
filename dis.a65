
;;; 65C02 disassembler
;;; to be incorporated into the monitor eventually, but for now
;;; written as a separate program.
;;;
;;; paul dourish, october 2017
;;;


;;;
;;; i'm following details and logic from
;;; http://www.llx.com/~nparker/a2/opcodes.html
;;;

;;; bottom two bits of instruction byte signal a block of instructions
;;; with differnt encoding patterns. so, start there.

start
  phx

  lda (BASE),y
  and #%00000011
  beq branch00      ; go to branch for cc=00
  cmp #%00000010
  beq branch10      ; go to brnach for cc=10
  cmp #%00000001
  bne others        ; go to branch for remaining opcodes
branch01
;;; cc=01?
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2
  lsr               ; the better to use as an index into opcode table
  tax
  ; so now cc01table,x is the pointer to the right string


  

  ;;; handle each addressing mode
  ;;; the addressing mode is going to determine how many
  ;;; bytes we need to consume overall
  lda (BASE),y
  and #%00011100
  beq indzpx
  cmp #%00000100
  beq zp
  cmp #%00001000
  beq imm
  cmp #%00001100
  beq abs
  cmp #%00010000
  beq izpy
  cmp #%00010100
  beq absy
absx
  ;; absolute, X -- consumes two more bytes
  lda #$20
  jsr puta
  iny
  iny
  lda (BASE),y
  jsr putax
  dey
  lda (BASE),y
  jsr putax
  iny
  jmp endline
izpx
  ;; (zero page,X) -- consumes one more byte
zp
  ;; zero page -- consumes one more byte
imm
  ;; immediate -- consumes one more byte
abs
  ;; absolute -- consumes two more bytes
izpy
  ;; (zero page),Y -- consumes one more byte
zpx
  ;; zero page,X -- consumes one more byte
absy
  ;; absolute,Y -- consumes two more bytes


  ;;
;;; cc=10?
branch10
;;; look up opcode

;;; handle each addressing mode

;;; special cases for STX and LDX

;; cc = 00?
branch00

;;; look up opcode

;;; handle each addressing mode (NOTE same as cc=10)


;;; branch instructions -- actually, these don't follow pattern so do FIRST
others
;;; branches have the form xxy10000
;;; xxy*2 should index into branchtable
;;; remaining special cases?





cc01table
  .word ORAstr, ANDstr, EORstr, ADCstr, STAstr, LDAstr, CMPstr, SBCstr

cc10table
  .word ASLstr, ROLstr, LSRstr, RORstr, STXstr, LDXstr, DECstr, INCstr

cc00table
  .word NONstr, BITstr, JMPstr, JMPstr, STYstr, LDYstr, CPYstr, CPXstr

branchtable
  .word BPLstr, BMIstr, BVCstr, BVSstr, BCCstr, BCSstr, BNEstr, BEQstr

ORAstr .byte "ORA"
ANDstr .byte "AND"
EORstr .byte "EOR"
ADCstr .byte "ADC"
STAstr .byte "STA"
LDAstr .byte "LDA"
CMPstr .byte "CMP"
SBCstr .byte "SBC"
ASLstr .byte "ASL"
ROLstr .byte "ROL"
LSRstr .byte "LSR"
RORstr .byte "ROR"
STXstr .byte "STX"
LDXstr .byte "LDX"
DECstr .byte "DEC"
INCstr .byte "INC"
NONstr .byte "???"
BITstr .byte "BIT"
JMPstr .byte "JMP"
STYstr .byte "STY"
LDYstr .byte "LDY"
CPYstr .byte "CPY"
CPXstr .byte "CPX"
BPLstr .byte "BPL"
BMIstr .byte "BMI"
BVCstr .byte "BVC"
BVSstr .byte "BVS"
BCCstr .byte "BCC"
BCSstr .byte "BCS"
BNEstr .byte "BNE"
BEQstr .byte "BEQ"


;;; this code makes no sense; it's here purely for test purposes
;;; as a disassembler target
testcode
  ldx #0
  lda #$66
  sta ($04),x
  bne next
  inx
next
  ora $4044
  cmp #ff
  adc ($77,y)
  rts
