
;;; 65C02 disassembler
;;;
;;; to be incorporated into the monitor eventually, but for now
;;; written as a separate program.
;;;
;;; paul dourish, october 2017
;;;

* = $0300

#include "decl.a65"

;;;
;;; i'm following details and logic from
;;; http://www.llx.com/~nparker/a2/opcodes.html
;;;
;;; most instructions are of the form aaabbbcc, where cc signals
;;; a block of instructons that operate in a similar way, with aaa
;;; indicating the instructoon and bbb indicating the addressing mode.
;;;

SCRATCH=$0010       ; through $001F
BASE=$0050          ; and $0051
COUNT=$0060

setup
  phx               ; preserve X (it's a stack pointer elsewhere)
  lda #<testcode    ; load testcode as our BASE for disassembly
  sta BASE
  lda #>testcode
  sta BASE+1
  lda #$20          ; number of instructions to decode
  sta COUNT
  ldy #0            ; y will track bytes as we go

start
nextinst
  ;; start the line by printing the address and a couple of spaces
  ;;
  lda BASE+1
  jsr putax
  lda BASE
  jsr putax
  lda #$20
  jsr puta
  jsr puta

  lda (BASE),y      ; get the instruction to decode
  beq jdobrk        ; special case for BRK
  cmp #$40
  beq jdorti        ; special case for RTI
  cmp #$60
  beq jdorts        ; special case for RTS

  and #%00011111    ; checking if it's a branch
  cmp #%00010000
  beq jbranch       ; jump to code for branches

  lda (BASE),y      ; get the instruction again (last test was destructive)
  and #%00000011    ; look at the "cc" bits -- what sort of opcode?
  beq jbranch00     ; go to branch for cc=00
  cmp #%00000010
  beq jbranch10     ; go to branch for cc=10
  cmp #%00000001
  bne jothers       ; go to branch for remaining opcodes
  jmp branch01

jbranch00
  jmp branch00
jbranch10
  jmp branch10
jbranch
  jmp branch
jdobrk
  jmp dobrk
jdorti
  jmp dorti
jdorts
  jmp dorts
jothers
  jmp others

;;; interpret according to the pattern for cc=01
;;;
branch01
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2, ...
  lsr               ; ... the better to use as index into opcode table
  tax
  ; so now cc01optable,x is the pointer to the right string
  lda cc01optable,x
  sta SCRATCH
  lda cc01optable+1,x
  sta SCRATCH+1
  phy
  ; print the three characters pointed to there
  ldy #0
  lda (SCRATCH),y   ; first character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; second character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; third character...
  jsr puta          ; print it
  lda #$20          ; print a space
  jsr puta
  ply
  
  ;;; handle each addressing mode
  ;;; the addressing mode is going to determine how many
  ;;; bytes we need to consume overall
  ;;; so we do something similar... grab the bits, shift them down
  ;;; and use that to look up a table which will tell us where
  ;;; to jump to to interpret it correctly.
  
  lda (BASE),y      ; get the instruction again
  and #%00011100    ; extract the bbb bits -- addressing mode
  lsr               ; shift just once
  ;; acc now holds the offset of the right entry in the table
  ;; now add in the base address of the table, and store it in SCRATCH
  clc
  adc #<cc01adtable
  sta SCRATCH       ; less significant byte
  lda #>cc01optable
  adc #0
  sta SCRATCH+1     ; most significant byte
  ;; one more level of indirection -- fetch the address listed there
  phy
  ldy #0
  lda (SCRATCH),y
  sta SCRATCH+2
  iny
  lda (SCRATCH),y
  sta SCRATCH+3
  ply
  jmp (SCRATCH+2)   ; jump to address specified in table
  


acc
  ;; accumulator
  lda #'A
  jsr puta
  jmp endline

absx
  ;; absolute, X -- consumes two more bytes
  lda #'$
  jsr puta
  iny               ; get the second (most-sig) byte first
  iny
  lda (BASE),y
  jsr putax
  dey               ; then the less-significant byte
  lda (BASE),y
  jsr putax
  iny               ; leave Y pointing to last byte consumed
  lda #',
  jsr puta
  lda #'X
  jsr puta
  jmp endline

izpx
  ;; (zero page,X) -- consumes one more byte
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #',
  jsr puta
  lda #'X
  jsr puta
  lda #')
  jsr puta
  jmp endline

zp
  ;; zero page -- consumes one more byte
  iny
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  jmp endline

imm
  ;; immediate -- consumes one more byte
  iny
  lda #'#
  jsr puta
  lda #'$
  jsr puta
  lda (BASE),y
  jsr putax
  jmp endline

immb
  ;; like immediate, but for branches (so ditch the "#")
  iny
  lda #'$
  jsr puta
  lda (BASE),y
  jsr putax
  jmp endline

abs
  ;; absolute -- consumes two more bytes
  lda #'$
  jsr puta
  iny               ; get the second (most-sig) byte first
  iny
  lda (BASE),y
  jsr putax
  dey               ; then the less-significant byte
  lda (BASE),y
  jsr putax
  iny
  jmp endline

izpy
  ;; (zero page),Y -- consumes one more byte
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #')
  jsr puta
  lda #',
  jsr puta
  lda #'Y
  jsr puta
  jmp endline

zpx
  ;; zero page,X -- consumes one more byte
  iny
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  jmp endline

absy
  ;; absolute,Y -- consumes two more bytes
  lda #'$
  jsr puta
  iny               ; get the second (most-sig) byte first
  iny
  lda (BASE),y
  jsr putax
  dey               ; then the less-significant byte
  lda (BASE),y
  jsr putax
  iny               ; leave Y pointing to last byte consumed
  lda #',
  jsr puta
  lda #'Y
  jsr puta
  jmp endline

err
  ;; can't interpret the opcode
  lda #'?
  jsr puta
  jsr puta
  jsr puta
;  jmp endline
  rts ; TEMPORARY!!!!

  ;;

;;; the next major block of addresses is those where the two
;;; bottom bits are 10. Processing is very similar to those
;;; where cc=01, above.
;;; almost all this code is just reproduced from above.
;;; TODO-- restructure to share more of the mechanics.
;;;
branch10

  ;; look up and process opcode first
  ;;
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2, ...
  lsr               ; ... the better to use as index into opcode table
  tax
  ; so now cc10optable,x is the pointer to the right string
  lda cc10optable,x
  sta SCRATCH
  lda cc10optable+1,x
  sta SCRATCH+1
  phy
  ; print the three characters pointed to there
  ldy #0
  lda (SCRATCH),y   ; first character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; second character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; third character...
  jsr puta          ; print it
  lda #$20          ; print a space
  jsr puta
  ply

  ;; handle each addressing mode
  ;;
  lda (BASE),y      ; get the instruction again
  and #%00011100    ; extract the bbb bits -- addressing mode
  lsr               ; shift just once
  ;; acc now holds the offset of the right entry in the table
  ;; now add in the base address of the table, and store it in SCRATCH
  clc
  adc #<cc10adtable
  sta SCRATCH       ; less significant byte
  lda #>cc10optable
  adc #0
  sta SCRATCH+1     ; most significant byte
  ;; one more level of indirection -- fetch the address listed there
  phy
  ldy #0
  lda (SCRATCH),y
  sta SCRATCH+2
  iny
  lda (SCRATCH),y
  sta SCRATCH+3
  ply
  jmp (SCRATCH+2)   ; jump to address specified in table

  ;;; TODO-- special cases for STX and LDX

;;; This code for the block of instructions with cc=00. Note again
;;; that this is simply repeated from above and should be fixed.
;;; TODO-- refactor this code to eliminate duplication
;;;
branch00
  ;; look up and process opcode first
  ;;
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2, ...
  lsr               ; ... the better to use as index into opcode table
  tax
  ; so now cc00optable,x is the pointer to the right string
  lda cc00optable,x
  sta SCRATCH
  lda cc00optable+1,x
  sta SCRATCH+1
  phy
  ; print the three characters pointed to there
  ldy #0
  lda (SCRATCH),y   ; first character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; second character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; third character...
  jsr puta          ; print it
  lda #$20          ; print a space
  jsr puta
  ply

  ;; handle each addressing mode
  ;;
  lda (BASE),y      ; get the instruction again
  and #%00011100    ; extract the bbb bits -- addressing mode
  lsr               ; shift just once
  ;; acc now holds the offset of the right entry in the table
  ;; now add in the base address of the table, and store it in SCRATCH
  clc
  adc #<cc00adtable
  sta SCRATCH       ; less significant byte
  lda #>cc00optable
  adc #0
  sta SCRATCH+1     ; most significant byte
  ;; one more level of indirection -- fetch the address listed there
  phy
  ldy #0
  lda (SCRATCH),y
  sta SCRATCH+2
  iny
  lda (SCRATCH),y
  sta SCRATCH+3
  ply
  jmp (SCRATCH+2)   ; jump to address specified in table



;;; branch instructions -- actually, these don't follow pattern so do FIRST
;;; branches have the form xxy10000
;;; xxy*2 should index into branchtable
branch
  lda (BASE),y
  and #%11100000
  lsr
  lsr
  lsr
  lsr

  ;; now index into table
  ; so now branchoptable,x is the pointer to the right string
  tax
  lda branchoptable,x
  sta SCRATCH
  lda branchoptable+1,x
  sta SCRATCH+1
  phy
  ; print the three characters pointed to there
  ldy #0
  lda (SCRATCH),y   ; first character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; second character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; third character...
  jsr puta          ; print it
  lda #$20          ; print a space
  jsr puta
  ply

  ;; we use a variant form of immediate mode to print the operand
  ;; for branch instructions
  jmp immb

others
  lda #'X
  jsr puta
  jsr crlf
  jmp endline

;; special cases go here
;;
dobrk
  lda #'B
  jsr puta
  lda #'R
  jsr puta
  lda #'K
  jsr puta
  jmp endline

dorti
  lda #'R
  jsr puta
  lda #'T
  jsr puta
  lda #'I
  jsr puta
  jmp endline

dorts
  lda #'R
  jsr puta
  lda #'T
  jsr puta
  lda #'S
  jsr puta
  jmp endline


endline
  jsr crlf

  ;; at this point, Y points to the last processed byte. Increment
  ;; to move on, and add it to base.
  iny
  clc
  tya               ; move Y to ACC and add to BASE address
  adc BASE
  sta BASE          ; low byte
  lda BASE+1
  adc #0
  sta BASE+1        ; high byte
  ldy #0            ; reset Y

  ;; test if we should terminate... goes here...
  dec COUNT
  beq finish

  jmp nextinst

finish
  rts



cc01optable
  .word ORAstr, ANDstr, EORstr, ADCstr, STAstr, LDAstr, CMPstr, SBCstr
cc01adtable
  .word izpx, zp, imm, abs, izpy, zpx, absy, absx

cc10optable
  .word ASLstr, ROLstr, LSRstr, RORstr, STXstr, LDXstr, DECstr, INCstr
cc10adtable
  .word imm, zp, acc, abs, err, zpx, err, absx

cc00optable
  ;; yes, JMP appears here twice... it's not a mistake...
  .word NONstr, BITstr, JMPstr, JMPstr, STYstr, LDYstr, CPYstr, CPXstr
cc00adtable
  .word imm, zp, err, abs, err, zpx, err, absx

branchoptable
  .word BPLstr, BMIstr, BVCstr, BVSstr, BCCstr, BCSstr, BNEstr, BEQstr

ORAstr .byte "ORA"
ANDstr .byte "AND"
EORstr .byte "EOR"
ADCstr .byte "ADC"
STAstr .byte "STA"
LDAstr .byte "LDA"
CMPstr .byte "CMP"
SBCstr .byte "SBC"
ASLstr .byte "ASL"
ROLstr .byte "ROL"
LSRstr .byte "LSR"
RORstr .byte "ROR"
STXstr .byte "STX"
LDXstr .byte "LDX"
DECstr .byte "DEC"
INCstr .byte "INC"
NONstr .byte "???"
BITstr .byte "BIT"
JMPstr .byte "JMP"
STYstr .byte "STY"
LDYstr .byte "LDY"
CPYstr .byte "CPY"
CPXstr .byte "CPX"
BPLstr .byte "BPL"
BMIstr .byte "BMI"
BVCstr .byte "BVC"
BVSstr .byte "BVS"
BCCstr .byte "BCC"
BCSstr .byte "BCS"
BNEstr .byte "BNE"
BEQstr .byte "BEQ"


puta
.(
  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts

;;;
;;; output the value in the accumulator as a hex pattern
;;; NB x cannot be guaranteed to be stack ptr during this... check...
;;;
putax
.(
  phy

  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  pha             ; put a copy back
  clc
  and #$f0
  ror
  ror
  ror
  ror
  tay
  lda hextable,y
  sta ACIA_DATA
wait_txd_empty2
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty2
  pla
  clc
  and #$0f
  tay
  lda hextable,y
  sta ACIA_DATA
.)
  ply
  rts

crlf
  pha
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0d
  sta ACIA_DATA
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0a
  sta ACIA_DATA
  pla
  rts

hextable:        .byte "0123456789ABCDEF"


;;; this code makes no sense; it's here purely for test purposes
;;; as a disassembler target
;;; at first, let's have a bunch of instructions from the cc01 table.
testcode
; testing cc=10
  lda ($01,x)
  lda $23
;  lda #45
;  lda $6789
;  lda ($ab),y
;  lda $cd,x
;  lda $ef01,y
;  lda $2345,x

; testing cc=01
  adc ($01,x)
  and $23
  cmp #45
;  eor $6789
;  lda ($ab),y
;  ora $cd,x
;  sbc $ef01,y
;  sta $2345,x
  asl
  dec $1234
  inc $5678
;  inc     ;; this is a 65C02 instruction... don't handle it yet?
  ldx #$9a
  rol
  lsr

; testing cc=00
  sty $1234
  sty $0056
  jmp $789a
  cpy #$bc
  cpx $def0

addr
; testing branches
  bne addr
  bvc addr
  bne addr
  beq addr

; testing special cases
  rts
  brk


