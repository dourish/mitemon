;;;
;;; Test harness for SPI video using RA8875 board. This is basically
;;; the command line code from the monitor and the SPI code from FORTH
;;; moved to use the user VIA port and jammed together awkwardly.
;;;

;;;
;;;
;;;
;;; definitions
;;;
;;;
;;;


SCRATCH    = $0010  ; through to $001F
ARGINDEX   = $0020  ; and on to $002F for up to 16 arguments
PRINTVEC   = $0042  ; and $0043. for printing routine.
ENTRY	   = $0044  ; and $0045
MEMTESTBASE= $0046  ; and $0047
INPUT      = $0200  ; block out this page for monitor command input

UVIA_PORTB = $8010
UVIA_PORTA = $8011
UVIA_DDRB  = $8012
UVIA_DDRA  = $8013

SPI_PORT   = UVIA_PORTB


;; colors
C_BLACK=$0000
C_BLUE=$001F 
C_RED=$F800  
C_GREEN=$07E0
C_CYAN=$07FF 
C_MAGENTA=$F81F
C_YELLOW=$FFE0 
C_WHITE=$FFFF  

;; Command/Data pins for SPI
DATAWRITE=$00
DATAREAD=$40 
CMDWRITE=$80 
CMDREAD =$C0  

;;;
;;; Include standard startup code
;;;

#include "../decl.a65"

jmp start

;;;
;;; Dispatch table for CLI
;;;
;;; each entry has a two-byte pointer to the next entry (or $0000 on end)
;;; then a null-terminated string that names the command
;;; then a two-type pointer for the code to execute the command
;;;
table
  .word table1
  .byte "init, $00
  .word doinit
table1
  .word table2
  .byte "help", $00
  .word dohelp
table2
  .word table3
  .byte "text", $00
  .word dotext
table3
  .word table4
  .byte "echo", $00
  .word doecho
table4
  .word table5
  .byte "graph", $00
  .word dograph
table5
  .word table6
  .byte "squares", $00
  .word dosquares
table6
  .word table7
  .byte "quit", $00
  .word doquit
table7
  .word $0000            ; signals last entry in the table
  .byte "colors", $00
  .word docolors



;;;
;;; SPI code
;;;
;;;


;;;
;;; Wiring details:
;;;   CLK is PB0, ie 1
;;;   MOSI is PB1, ie 2
;;;   CS is PB2, ie 4
;;;   MISO is PB7, which maps onto S flag on BIT (test with BPL and BMI)
;;; MISO, MOSI, and CS all have pull-up resisters, so they are high in
;;; the idle/unused state, except when pulled low by active circuitry.
;;;
;;; For the moment, this is the same setup as the SD card reader.
;;; Since I want to be able to set things up for keyboard input on
;;; on the same port, I'm likely to want to move some of the lines
;;; around later. However, for now, I wannt to use validated code.
;;;
;;; Other bits:
;;;    BACKLIGHT  PB3, ie 8
;;;    BUSY       PB4, ie 16
;;;

SPI_CLK  = 1
SPI_MOSI = 2
SPI_CS   = 4
SPI_MISO = 128
BUSYMASK = 16

;;; set up data direction for SPI_PORT -- lower four bits are outputs
;;; and upper four bits are inputs. This is called from FORTH startup.
setup6522
  lda #15
  sta UVIA_DDRB
  rts


SPI_CMD=64

cmd0
  ;; set cs to 0
  lda #SPI_CS
  trb SPI_PORT

  ;; send cmd0 (01+6*0 + 24*0 + 10010101)
  lda #SPI_CMD+0
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #%10010101    ; CRC plus end bit
  jsr sendbyte

  jsr setidle       ; set to idle to await input
  jsr getresponse   ; get single byte response

  ldy #SPI_CS+SPI_MOSI ; set CS and MOSI high to release card
  sty SPI_PORT
  rts

setidle
  ldy #%00000010    ; CLK off, MOSI high, CS low
  sty SPI_PORT
  rts  

;; send an $ff... this is basically just about creating delays
;; between commands
sendff
  ;; set cs to 1
  lda #SPI_CS
  tsb SPI_PORT
  lda #$ff
  jsr sendbyte
  rts

cmd8
  ;; set cs to 0
  lda #4
  trb SPI_PORT

  ;; send cmd8 with parameter 0x000001aa
  lda #SPI_CMD+8
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  lda #1
  jsr sendbyte
  lda #$aa
  jsr sendbyte
  lda #$87          ; crc
  jsr sendbyte

  jsr setidle
  jsr await40bits

  lda #SPI_CS+SPI_MOSI  ; release card (CS and MOSI high)
  sta SPI_PORT

  rts

cmd58
  ;; set cs to 0
  lda #4
  trb SPI_PORT

  ;; send cmd58
  lda #SPI_CMD+58
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #%01110101
  jsr sendbyte

  jsr setidle
  jsr await40bits

  lda #SPI_CS+SPI_MOSI  ; release card (CS and MOSI high)
  sta SPI_PORT

  rts


cmd55
  ;; set cs to 0
  lda #SPI_CS
  trb SPI_PORT

  ;; send cmd55 with parameter 0
  lda #SPI_CMD+55
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; crc
  jsr sendbyte

  jsr setidle
  jsr getresponse
  ldy #6
  sty SPI_PORT
  rts

  
acmd41
  ;; set cs to 0
  lda #4
  trb SPI_PORT

  lda #SPI_CMD+41
  jsr sendbyte
  lda #%01000000    ; bit 30 is HCS flag
  jsr sendbyte
  lda #16           ; bit 20 selects 3.2-3.3V
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; checksum, but doesn't matter in SPI mode?
  jsr sendbyte

  jsr setidle
  jsr getresponse

  ldy #6
  sty SPI_PORT
  rts

cmd17
  ;; set cs to 0
  lda #SPI_CS
  trb SPI_PORT

  ;; send cmd17 with parameter 0
  lda #SPI_CMD+17
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; crc, doesn't matter
  jsr sendbyte

  jsr setidle
  jsr getresponse
  rts


gettoken
  ; listen until we hear %11111110 (254/$FE)
  jsr recv8bits
  cmp #$FE
  bne gettoken
  rts


sendtoken
  lda #254
  jsr sendbyte
  rts



sendbyte
  phy
  ldy #8
sendloop
  asl
  pha
  bcc sendzero
sendone
  lda #SPI_MOSI
  tsb SPI_PORT
  bra send
sendzero
  lda #SPI_MOSI
  trb SPI_PORT
send
  inc SPI_PORT
  dec SPI_PORT
  pla
  dey
  bne sendloop
  ply
  rts

;; wait for data by pulsing the clock until there's a zero on MISO
awaitdata
.(
  inc SPI_PORT         ; set CLK high
  bit SPI_PORT         ; check for data on MISO
  bpl done          ; exit if we see a zdero
  dec SPI_PORT         ; otherwise, set CLK low and 
  bra awaitdata     ; loop around again
done
  dec SPI_PORT
.)
  rts

;; wait with a timeout. if we don't hear something within 256 pulses,
;; set carry flag and return
awaittimeout
.(
  clc
  ldy #0
awaitloop
  inc SPI_PORT
  bit SPI_PORT
  bpl done
  dec SPI_PORT
  dey
  beq timeout
  bra awaitloop
timeout
  sec
  rts
done
  dec SPI_PORT
  rts
.)

;; wait for data and then receive a byte starting with zero
awaitbyte
  jsr awaitdata
  lda #0
  jmp recv7bits

;; wait for byte with timeout (signalled with carry)
awaitbto
  jsr awaittimeout
  bcs timeout
  lda #0
  jmp recv7bits
timeout
  rts
  
await40bits
  jsr awaitdata     ; wait for any data
  jsr recv7bits     ; grab first 7 bits (presuming leading 0)
  sta SCRATCH
  jsr recv8bits     ; second byte
  sta SCRATCH+1
  jsr recv8bits     ; third byte
  sta SCRATCH+2
  jsr recv8bits     ; fourth byte
  sta SCRATCH+3
  jsr recv8bits     ; fifth byte
  sta SCRATCH+4
  rts

getresponse
.(
  phx
  ldx #0
loop
  inx
  beq timedout
  jsr recv8bits
  cmp #$ff
  beq loop
timedout
  plx
  rts
.)

;; read a byte via SPI from SPI_PORT, returned in accumulator.
recv8bits
  lda #0            ; zero out result
  inc SPI_PORT      ; set clock high
  lda SPI_PORT      ; read data
  cmp #128          ; this sets carry flag to top bit
  rol               ; shift carry into A
  dec SPI_PORT      ; set clock off
  ;; now fall through to receive next seven bits

;; this is a separate entry point used when we've already read or
;; tested one bit.
recv7bits           ; used to be a loop, unrolled for speed
.(
  phx               ; store X, since we'll use it (and can't use Y)

  inc SPI_PORT      ; set CLK high #1
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #2
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #3
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #4
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #5
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #6
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #7
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  plx               ; restore X
.)
  rts               ; return with data in A


awaitfree
  pha
  lda SPI_PORT
  and BUSYMASK
  bne awaitfree
  pla
  rts

wrcommand
  pha
  ;; set CS low
  lda #SPI_CS
  trb SPI_PORT

  ;; send CMDWRITE
  lda CMDWRITE
  jsr sendbyte
  pla
  ;; send A
  jsr sendbyte
  ;; set CS high
  lda #SPI_CS
  tsb SPI_PORT
  rts


rdcommand

wrdata
  pha
  ;; set CS low
  lda #SPI_CS
  trb SPI_PORT
  ;; send DATAWRITE
  lda DATAWRITE
  jsr sendbyte
  pla
  ;; send A
  jsr sendbyte
  ;; set CS high
  lda #SPI_CS
  tsb SPI_PORT
  rts

rddata
  ;; set CS low
  lda #SPI_CS
  trb SPI_PORT
  ;; send DATAREAD
  lda DATAREAD
  ;; receive data into A
  jsr recv8bits
  pha
  ;; set CS high
  lda #SPI_CS
  tsb SPI_PORT
  pla
  rts


;;;
;;;
;;; MAIN CODE ENTRY POINT
;;;
;;;

start

  ;; initialization?
  ;;

  phx               ; preserve x, since it's our private stack pointer
                    ; only valuable if we ever return of course

  jsr setup6522     ; set up the port

  lda #<greeting
  sta PRINTVEC
  lda #>greeting+1
  sta PRINTVEC+1
  jsr printvecstr


;;;
;;;
;;; COMMAND LINE INTERPRETER
;;;
;;;

reploop
.(
  ;; print the prompt
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda prompt
  sta ACIA_DATA
.)

  jsr readline      ; read a line into INPUT
  jsr crlf          ; echo line feed/carriage return

  ;; nothing entered? loop again
  cpy #0
  beq reploop

  ;; parse and process the command line
  ;;
  lda #0           
  sta INPUT,y       ; null-terminate the string
  jsr parseinput    ; parse into individual arguments, indexed at ARGINDEX
  jsr matchcommand  ; match input command and execute
  jmp reploop       ; loop around


parseinput
  ldx #0
  ldy #0

.(
;; look for non-space
nextchar
  lda INPUT,x
  cmp #32
  bne nonspace
  inx
  jmp nextchar

;; mark the start of the word
nonspace
  iny               ; maintain a count of words in y
  stx ARGINDEX,y
;; look for space
lookforspace
  inx
  lda INPUT,x
  beq endofline     ; check for null termination
  cmp #32           ; only looking for spaces. Tab?
  beq endofword
  jmp lookforspace
;; didn't hit a terminator, so there must be more.
;; terminate this word with a zero and then continue
endofword
  lda #0
  sta INPUT,x         ; null-terminate
  inx
  jmp nextchar        ; repeat
endofline
  ;; we're done
  ;; cache the arg count
  sty ARGINDEX

  rts
.)


;;;
;;; Command lookup and dispatch. Search the table for a string that
;;; matches the command entered. If it is found, jump to it. ENTRY
;;; points to the current entry in the table as we step through the
;;; list of commands.
;;;
;;; This is called as a subroutine. We jump to the code, so an rts
;;; from there will return to the interpeter loop; if we hit an error,
;;; we rts from here with the same effect.
;;;

matchcommand
  lda #<table    ; low byte of table address
  sta ENTRY
  lda #>table    ; high byte of table address
  sta ENTRY+1

testentry
cacheptr
  ;; grab the pointer to the next entry and cache it in scratchpad
  ldy #0
  lda (ENTRY),Y  ; first byte
  sta SCRATCH
  iny
  lda (ENTRY),Y  ; second byte
  sta SCRATCH+1
  iny
  ldx #0         ;; will use X and Yas index for string
.(
nextchar
  lda INPUT,x
  beq endofword
  cmp (ENTRY),y
  bne nextentry
  inx
  iny
  jmp nextchar
.)

endofword
  ;; we got here because we hit the end of the word in the buffer
  ;; if it's also the end of the entry label, then we've found the right place
  lda (ENTRY),y
  beq successful
  ;; but if it's not, then we haven't.
  ;; continue to the next entry
  jmp nextentry

successful
  ;; we got a match! copy out the destination address, jump to it
  iny
  lda (ENTRY),Y
  sta SCRATCH+2
  iny
  lda (ENTRY),Y
  sta SCRATCH+3
  jmp (SCRATCH+2)
  rts  ;; never get here -- we rts from the command code
    
nextentry
  lda SCRATCH           ;; copy the address of next entry from scratchpad
  sta ENTRY
  lda SCRATCH+1
  sta ENTRY+1
  ;; test for null here
  ora SCRATCH       ;; check if the entry was $0000
  beq endoftable    ;; if so, we're at the end of table
  jmp testentry

endoftable
  ;; got to the end of the table with no match
  ;; print an error message, and return to line input
  ;; ...

printerror
  lda #<nocmderrstr
  sta PRINTVEC
  lda #>nocmderrstr
  sta PRINTVEC+1
  jsr printvecstr
  rts



;;;
;;;
;;; COMMANDS CALLED FROM THE INTERPETER
;;;
;;;

dohelp
  lda #<helpstring
  sta PRINTVEC
  lda #>helpstring
  sta PRINTVEC+1
  jsr printvecstr
  rts

doecho
.(
  ldy #1                  ; start at 1 because we ignore the command itself
echonext
  cpy ARGINDEX            ; have we just done the last?
  beq end                 ; yes, so end
  iny                     ; no, so move on to the next
  ldx ARGINDEX,y
  ;; not using printvecstr for this because we're printing
  ;; directly out of the input buffer  
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda INPUT,x
  beq endofarg
  sta ACIA_DATA
  inx
  jmp next_char
endofarg
  lda #32                  ; put a space at the end
  jsr puta
  jmp echonext
end
  jsr crlf                 ; carriage return/line feed
  plx                      ; restore the stack pointer
  rts
.)


doquit
  pla               ; drop the most recent return address
  pla               ; so that we will return instead to the monitor
  plx               ; restore the FORTH stack pointer
  rts               ; exit


doinit
  rts

dotext
  ;; wait until free
  ;; send command 0x40 (MWCR0 register)
  ;; read response
  ;; set bit 7
  ;; write it back as data
  rts

dograph
  rts

dohello
  rts

dosquares
  rts

docolors
  rts





;;;;;;;;;;;;;
;;;
;;; Various utility routines
;;;
;;;;;;;;;;;;;

;;;
;;; Ouptut carriage return and line feed
;;;
crlf
  pha
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0d
  sta ACIA_DATA
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0a
  sta ACIA_DATA
  pla
  rts


;;;
;;; output the character code in the accumulator
;;;
puta
.(
  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts

;;;
;;; output the value in the accumulator as a hex pattern
;;; NB x cannot be guaranteed to be stack ptr during this... check...
;;;
putax
.(
  phy

  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  pha             ; put a copy back
  clc
  and #$f0
  ror
  ror
  ror
  ror
  tay
  lda hextable,y
  sta ACIA_DATA
wait_txd_empty2
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty2
  pla
  clc
  and #$0f
  tay
  lda hextable,y
  sta ACIA_DATA
.)
  ply
  rts


;;; read a line of input from the serial interface
;;; leaves data in the buffer at INPUT
;;; y is the number of characters in the line, so it will fail if
;;; more then 255 characters are entered
;;; line terminated by carriage return. backspaces processed internally.
;;;
readline
  ldy #0
readchar
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA
  cmp #$08           ; check for backspace
  beq backspace
  cmp #$0D           ; check for newline
  beq done
  sta INPUT,y        ; track the input
  iny
  jsr puta           ; echo the typed character
  jmp readchar       ; loop to repeat
backspace
  cpy #0             ; beginning of line?
  beq readchar
  dey                ; if not, go back one character
  jsr puta           ; move cursor back
  jmp readchar

  ;; this is where we land if the line input has finished
  ;;
done
  rts




;;; print the string pointed to at PRINTVEC
;;;
printvecstr
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda (PRINTVEC),y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
.)
  rts




;;;
;;; Various string constants
;;;

hextable:	 .byte "0123456789ABCDEF"
greeting:	 .byte "SPI Video test", $0d, $0a, $00
prompt:		 .byte "-"
helpstring:	 .byte "Commands available: init, text, graph, echo, squares, colors, quit", $0d, $0a, $00
nocmderrstr:	 .byte "Command not recognized", $0d, $0a, $00
