;;;
;;; Test harness for SPI video using RA8875 board. This is basically
;;; the command line code from the monitor and the SPI code from FORTH
;;; moved to use the user VIA port and jammed together awkwardly.
;;;


;;;
;;;
;;;
;;; definitions
;;;
;;;
;;;


SCRATCH    = $0010  ; through to $001F

ARGINDEX   = $0020  ; and on to $002F for up to 16 arguments
;; block $0030-003F for xmodem variables
;; $0040 is free
;; $0041 is free
PRINTVEC   = $0042  ; and $0043. for printing routine.
ENTRY	   = $0044  ; and $0045
MEMTESTBASE= $0046  ; and $0047
;; $0080-00FF is my operand stack
;; $0100-01FF is 6502 stack
INPUT      = $0200  ; block out this page for monitor command input
;; $0300-03FF is blocked for xmodem buffer
;; $0400-04FF is blocked for xmodem testing (temporary)

;;;
;;; Include standard startup code
;;;

#include "../decl.a65"

jmp start

;;; Dispatch table
;;;
;;; each entry has a two-byte pointer to the next entry (or $0000 on end)
;;; then a null-terminated string that names the command
;;; then a two-type pointer for the code to execute the command
;;;
table
  .word table1
  .byte "init, $00
  .word doinit
table1
  .word table2
  .byte "help", $00
  .word dohelp
table2
  .word table3
  .byte "text", $00
  .word dotext
table3
  .word table4
  .byte "echo", $00
  .word doecho
table4
  .word table5
  .byte "graph", $00
  .word dograph
table5
  .word table6
  .byte "squares", $00
  .word dosquares
table6
  .word table7
  .byte "quit", $00
  .word doquit
table7
  .word $0000            ; this signals it's the last entry in the table
  .byte "colors", $00
  .word docolors



;;;
;;; SPI code
;;;
;;;


;;;
;;; Wiring details:
;;;   CLK is PB0, ie 1
;;;   MOSI is PB1, ie 2
;;;   CS is PB2, ie 4
;;;   CD is PB6, ie 64 (CD = card detect)
;;;   MISO is PB7, which maps onto S flag on BIT (test with BPL and BMI)
;;; MISO, MOSI, and CS all have pull-up resisters, so they are high in
;;; the idle/unused state, except when pulled low by active circuitry.
;;;

SPI_CLK  = 1
SPI_MOSI = 2
SPI_CS   = 4
SPI_MISO = 128

;;; LOWEST LAYER (SPI PROTOCOL)
;;;

;;; set up data direction for PORTB -- lower four bits are outputs
;;; and upper four bits are inputs. This is called from FORTH startup.
setup6522
  lda #15
  sta VIA_DDRB
  rts


;;; initialize the SD card and set it to SPI mode.
resetsd
  lda #SPI_CS+SPI_MOSI  ; set MOSI and CS to 1
  sta PORTB

  ;; toggle CLK at least 74 times (ie do 80, for 10 bytes of FF)
  ;;
  ldy #80
.(
initloop
  inc PORTB
  dec PORTB
  dey
  bne initloop
.)
  rts

SPI_CMD=64

cmd0
  ;; set cs to 0
  lda #SPI_CS
  trb PORTB

  ;; send cmd0 (01+6*0 + 24*0 + 10010101)
  lda #SPI_CMD+0
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #%10010101    ; CRC plus end bit
  jsr sendbyte

  jsr setidle       ; set to idle to await input
  jsr getresponse   ; get single byte response

  ldy #SPI_CS+SPI_MOSI ; set CS and MOSI high to release card
  sty PORTB
  rts

setidle
  ldy #%00000010    ; CLK off, MOSI high, CS low
  sty PORTB
  rts  

;; send an $ff... this is basically just about creating delays
;; between commands
sendff
  ;; set cs to 1
  lda #SPI_CS
  tsb PORTB
  lda #$ff
  jsr sendbyte
  rts

cmd8
  ;; set cs to 0
  lda #4
  trb PORTB

  ;; send cmd8 with parameter 0x000001aa
  lda #SPI_CMD+8
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  lda #1
  jsr sendbyte
  lda #$aa
  jsr sendbyte
  lda #$87          ; crc
  jsr sendbyte

  jsr setidle
  jsr await40bits

  lda #SPI_CS+SPI_MOSI  ; release card (CS and MOSI high)
  sta PORTB

  rts

cmd58
  ;; set cs to 0
  lda #4
  trb PORTB

  ;; send cmd58
  lda #SPI_CMD+58
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #%01110101
  jsr sendbyte

  jsr setidle
  jsr await40bits

  lda #SPI_CS+SPI_MOSI  ; release card (CS and MOSI high)
  sta PORTB

  rts


cmd55
  ;; set cs to 0
  lda #SPI_CS
  trb PORTB

  ;; send cmd55 with parameter 0
  lda #SPI_CMD+55
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; crc
  jsr sendbyte

  jsr setidle
  jsr getresponse
  ldy #6
  sty PORTB
  rts

  
acmd41
  ;; set cs to 0
  lda #4
  trb PORTB

  lda #SPI_CMD+41
  jsr sendbyte
  lda #%01000000    ; bit 30 is HCS flag
  jsr sendbyte
  lda #16           ; bit 20 selects 3.2-3.3V
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; checksum, but doesn't matter in SPI mode?
  jsr sendbyte

  jsr setidle
  jsr getresponse

  ldy #6
  sty PORTB
  rts

cmd17
  ;; set cs to 0
  lda #SPI_CS
  trb PORTB

  ;; send cmd17 with parameter 0
  lda #SPI_CMD+17
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; crc, doesn't matter
  jsr sendbyte

  jsr setidle
  jsr getresponse
  rts


gettoken
  ; listen until we hear %11111110 (254/$FE)
  jsr recv8bits
  cmp #$FE
  bne gettoken
  rts


sendtoken
  lda #254
  jsr sendbyte
  rts



sendbyte
  phy
  ldy #8
sendloop
  asl
  pha
  bcc sendzero
sendone
  lda #SPI_MOSI
  tsb PORTB
  bra send
sendzero
  lda #SPI_MOSI
  trb PORTB
send
  inc PORTB
  dec PORTB
  pla
  dey
  bne sendloop
  ply
  rts

;; wait for data by pulsing the clock until there's a zero on MISO
awaitdata
.(
  inc PORTB         ; set CLK high
  bit PORTB         ; check for data on MISO
  bpl done          ; exit if we see a zdero
  dec PORTB         ; otherwise, set CLK low and 
  bra awaitdata     ; loop around again
done
  dec PORTB
.)
  rts

;; wait with a timeout. if we don't hear something within 256 pulses,
;; set carry flag and return
awaittimeout
.(
  clc
  ldy #0
awaitloop
  inc PORTB
  bit PORTB
  bpl done
  dec PORTB
  dey
  beq timeout
  bra awaitloop
timeout
  sec
  rts
done
  dec PORTB
  rts
.)

;; wait for data and then receive a byte starting with zero
awaitbyte
  jsr awaitdata
  lda #0
  jmp recv7bits

;; wait for byte with timeout (signalled with carry)
awaitbto
  jsr awaittimeout
  bcs timeout
  lda #0
  jmp recv7bits
timeout
  rts
  
await40bits
  jsr awaitdata     ; wait for any data
  jsr recv7bits     ; grab first 7 bits (presuming leading 0)
  sta SCRATCH
  jsr recv8bits     ; second byte
  sta SCRATCH+1
  jsr recv8bits     ; third byte
  sta SCRATCH+2
  jsr recv8bits     ; fourth byte
  sta SCRATCH+3
  jsr recv8bits     ; fifth byte
  sta SCRATCH+4
  rts

getresponse
.(
  phx
  ldx #0
loop
  inx
  beq timedout
  jsr recv8bits
  cmp #$ff
  beq loop
timedout
  plx
  rts
.)

;; read a byte via SPI from PORTB, returned in accumulator.
recv8bits
  lda #0            ; zero out result
  inc PORTB         ; set clock high
  lda PORTB         ; read data
  cmp #128          ; this sets carry flag to top bit
  rol               ; shift carry into A
  dec PORTB         ; set clock off
  ;; now fall through to receive next seven bits

;; this is a separate entry point used when we've already read or
;; tested one bit.
recv7bits           ; used to be a loop, unrolled for speed
.(
  phx               ; store X, since we'll use it (and can't use Y)

  inc PORTB         ; set CLK high #1
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #2
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #3
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #4
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #5
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #6
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #7
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  plx               ; restore X
.)
  rts               ; return with data in A



;;;
;;; interative entry point
;;;




start

;; initialization?
;;

  phx               ; preserve x, since it's our private stack pointer
                    ; only valuable if we ever return of course
  lda #<greeting
  sta PRINTVEC
  lda #>greeting+1
  sta PRINTVEC+1
  jsr printvecstr

main

;;;
;;; now down to business. this is the main entrypoint for the
;;; read/execution loop. print a prompt, read a line, parse, dispatch,
;;; repeat.
;;;
reploop
.(
  ;; print the prompt
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda prompt
  sta ACIA_DATA
.)

  jsr readline      ; read a line into INPUT
  jsr crlf          ; echo line feed/carriage return

  ;; nothing entered? loop again
  cpy #0
  beq reploop

  ;; parse and process the command line
  ;;
  lda #0           
  sta INPUT,y       ; null-terminate the string
  jsr parseinput    ; parse into individual arguments, indexed at ARGINDEX
  jsr matchcommand  ; match input command and execute
  jmp reploop       ; loop around


parseinput
  ldx #0
  ldy #0

.(
;; look for non-space
nextchar
  lda INPUT,x
  cmp #32
  bne nonspace
  inx
  jmp nextchar

;; mark the start of the word
nonspace
  iny               ; maintain a count of words in y
  stx ARGINDEX,y
;; look for space
lookforspace
  inx
  lda INPUT,x
  beq endofline     ; check for null termination
  cmp #32           ; only looking for spaces. Tab?
  beq endofword
  jmp lookforspace
;; didn't hit a terminator, so there must be more.
;; terminate this word with a zero and then continue
endofword
  lda #0
  sta INPUT,x         ; null-terminate
  inx
  jmp nextchar        ; repeat
endofline
  ;; we're done
  ;; cache the arg count
  sty ARGINDEX

  ;; restore x and return
  rts
.)


;;;;;;;;;;;;;
;;;
;;; Command lookup/dispatch
;;;
;;;;;;;;;;;;;


matchcommand
  lda #<table    ; low byte of table address
  sta ENTRY
  lda #>table    ; high byte of table address
  sta ENTRY+1

testentry
cacheptr
  ;; grab the pointer to the next entry and cache it in scratchpad
  ldy #0
  lda (ENTRY),Y  ; first byte
  sta SCRATCH
  iny
  lda (ENTRY),Y  ; second byte
  sta SCRATCH+1
  iny
  ldx #0         ;; will use X and Yas index for string
.(
nextchar
  lda INPUT,x
  beq endofword
  cmp (ENTRY),y
  bne nextentry
  inx
  iny
  jmp nextchar
.)

endofword
  ;; we got here because we hit the end of the word in the buffer
  ;; if it's also the end of the entry label, then we've found the right place
  lda (ENTRY),y
  beq successful
  ;; but if it's not, then we haven't.
  ;; continue to the next entry
  jmp nextentry

successful
  ;; we got a match! copy out the destination address, jump to it
  iny
  lda (ENTRY),Y
  sta SCRATCH+2
  iny
  lda (ENTRY),Y
  sta SCRATCH+3
  jmp (SCRATCH+2)
  rts  ;; never get here -- we rts from the command code
    
nextentry:
  lda SCRATCH           ;; copy the address of next entry from scratchpad
  sta ENTRY
  lda SCRATCH+1
  sta ENTRY+1
  ;; test for null here
  ora SCRATCH       ;; check if the entry was $0000
  beq endoftable    ;; if so, we're at the end of table
  jmp testentry

endoftable
  ;; got to the end of the table with no match
  ;; print an error message, and return to line input
  ;; ...

printerror
  lda #<nocmderrstr
  sta PRINTVEC
  lda #>nocmderrstr
  sta PRINTVEC+1
  jsr printvecstr
  ; no need for crlf
;  ldy #0
;.(
;next_char
;wait_txd_empty  
;  lda ACIA_STATUS
;  and #$10
;  beq wait_txd_empty
;  lda errorstring,y
;  beq end
;  sta ACIA_DATA
;  iny
;  jmp next_char
;end
;.)
  rts



;;;;;;;;;;;;;
;;;
;;; Monitor commands
;;;
;;;;;;;;;;;;;

dohelp
  lda #<helpstring
  sta PRINTVEC
  lda #>helpstring
  sta PRINTVEC+1
  jsr printvecstr
  rts

notimplcmd
  lda #<implementstring
  sta PRINTVEC
  lda #>implementstring
  sta PRINTVEC+1
  jsr printvecstr
  rts

doecho
.(
  ldy #1                  ; start at 1 because we ignore the command itself
echonext
  cpy ARGINDEX            ; have we just done the last?
  beq end                 ; yes, so end
  iny                     ; no, so move on to the next
  ldx ARGINDEX,y
  ;; not using printvecstr for this because we're printing
  ;; directly out of the input buffer  
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda INPUT,x
  beq endofarg
  sta ACIA_DATA
  inx
  jmp next_char
endofarg
  lda #32                  ; put a space at the end
  jsr puta
  jmp echonext
end
  jsr crlf                 ; carriage return/line feed
  plx                      ; restore the stack pointer
  rts
.)



doquit
  pla               ; drop the most recent return address
  pla               ; so that we will return instead to the monitor
  plx               ; restore the FORTH stack pointer
  rts               ; exit


doinit
  rts

dotext
  rts

dograph
  rts

dohello
  rts

dosquares
  rts

docolors
  rts



;;;;;;;;;;;;;
;;;
;;; Various utility routines
;;;
;;;;;;;;;;;;;

;;;
;;; Ouptut carriage return and line feed
;;;
crlf
  pha
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0d
  sta ACIA_DATA
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0a
  sta ACIA_DATA
  pla
  rts


;;;
;;; output the character code in the accumulator
;;;
puta
.(
  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts

;;;
;;; output the value in the accumulator as a hex pattern
;;; NB x cannot be guaranteed to be stack ptr during this... check...
;;;
putax
.(
  phy

  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  pha             ; put a copy back
  clc
  and #$f0
  ror
  ror
  ror
  ror
  tay
  lda hextable,y
  sta ACIA_DATA
wait_txd_empty2
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty2
  pla
  clc
  and #$0f
  tay
  lda hextable,y
  sta ACIA_DATA
.)
  ply
  rts


;;; read a line of input from the serial interface
;;; leaves data in the buffer at INPUT
;;; y is the number of characters in the line, so it will fail if
;;; more then 255 characters are entered
;;; line terminated by carriage return. backspaces processed internally.
;;;
readline
  ldy #0
readchar
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA
  cmp #$08           ; check for backspace
  beq backspace
  cmp #$0D           ; check for newline
  beq done
  sta INPUT,y        ; track the input
  iny
  jsr puta           ; echo the typed character
  jmp readchar       ; loop to repeat
backspace
  cpy #0             ; beginning of line?
  beq readchar
  dey                ; if not, go back one character
  jsr puta           ; move cursor back
  jmp readchar

  ;; this is where we land if the line input has finished
  ;;
done
  rts




;;; print the string pointed to at PRINTVEC
;;;
printvecstr
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda (PRINTVEC),y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
.)
  rts





;;;
;;; Various string constants
;;;

hextable:	 .byte "0123456789ABCDEF"
greeting:	 .byte "SPI Video test", $0d, $0a, $00
prompt:		 .byte "-"
helpstring:	 .byte "Commands available: init, text, graph, echo, squares, colors, quit", $0d, $0a, $00
nocmderrstr:	 .byte "Command not recognized", $0d, $0a, $00
implementstring: .byte "Not yet implemented", $0d, $0a, $00
dumperrstring:   .byte "Usage: dump hexaddress [count:10]", $00
char:		 .byte "."
