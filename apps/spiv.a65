;;;
;;; Test harness for SPI video using RA8875 board. This is basically
;;; the command line code from the monitor and the SPI code from FORTH
;;; moved to use the user VIA port and jammed together awkwardly.
;;;
;;; Paul Dourish, June 2021
;;;

;;;
;;; Pinout from the 6522 (PORTB) to the RA8875 board is as follows:
;;; D0  CLK
;;; D1  MOSI
;;; D2  CS
;;; D3  LIGHT (currentl unused)
;;; D4  BUSY (currently unused)
;;; D5  RESET
;;; D6  NC
;;; D7  MISO
;;;


;;;
;;; Definitions for constants
;;;
;;;
;;;

* = $0300

SCRATCH    = $0010  ; through to $001F
ARGINDEX   = $0020  ; and on to $002F for up to 16 arguments
PRINTVEC   = $0042  ; and $0043. for printing routine.
ENTRY	   = $0044  ; and $0045
MEMTESTBASE= $0046  ; and $0047
INPUT      = $0200  ; block out this page for monitor command input

UVIA_PORTB = $8010
UVIA_PORTA = $8011
UVIA_DDRB  = $8012
UVIA_DDRA  = $8013

SPI_PORT   = UVIA_PORTB


;; Command/Data codes for SPI
DATAWRITE=$00
DATAREAD=$40 
CMDWRITE=$80 
CMDREAD =$C0  

;;;
;;; Include standard startup code
;;;

#include "../decl.a65"

;;; also include all the RA8875-specific definitions
#include "spivdefs.a65"

jmp start

#include "delay.a65"

;;;
;;; Dispatch table for CLI
;;;
;;; each entry has a two-byte pointer to the next entry (or $0000 on end)
;;; then a null-terminated string that names the command
;;; then a two-type pointer for the code to execute the command
;;;
table
  .word table1
  .byte "init", $00
  .word doinit
table1
  .word table2
  .byte "help", $00
  .word dohelp
table2
  .word table3
  .byte "text", $00
  .word dotext
table3
  .word table4
  .byte "echo", $00
  .word doecho
table4
  .word table5
  .byte "graph", $00
  .word dograph
table5
  .word table6
  .byte "squares", $00
  .word dosquares
table6
  .word table7
  .byte "quit", $00
  .word doquit
table7
  .word table8
  .byte "move", $00
  .word domove
table8
  .word table9
  .byte "hello", $00
  .word dohello
table9
  .word table10
  .byte "cursor", $00
  .word docursor
table10
  .word table11
  .byte "pos", 0
  .word dopos
table11
  .word table12
  .byte "vinit", 0
  .word dovinit
table12
  .word table13
  .byte "white", 0
  .word dowhite
table13
  .word table14
  .byte "red", 0
  .word dored
table14
  .word table15
  .byte "blue", 0
  .word doblue
table15
  .word table16
  .byte "unsetscroll", 0
  .word dounsetscroll
table16
  .word table17
  .byte "reginit", 0
  .word doreginit
table17
  .word table18
  .byte "display", 0
  .word dodisplay
table18
  .word table19
  .byte "reg0", 0
  .word doreg0
table19
  .word table20
  .byte "scrollup", 0
  .word doscrollup
table20
  .word table21
  .byte "finish", 0
  .word dofinish
table21
  .word table22
  .byte "input", 0
  .word doinput
table22
  .word table23
  .byte "nl", 0
  .word donewline
table23
  .word table24
  .byte "color?", 0
  .word docolorq
table24
  .word table25
  .byte "pwm?", 0
  .word dopwmq
table25
  .word table26
  .byte "font", 0
  .word dofont
table26
  .word table27
  .byte "size", 0
  .word dosize
table27
  .word table28
  .byte "fg", 0
  .word dofg
table28
  .word table29
  .byte "bg", 0
  .word dobg
table29
  .word table30
  .byte "setscroll", 0
  .word dosetscroll
table30
  .word table31
  .byte "scroll", 0
  .word doscroll
table31
  .word table32
  .byte "fill", 0
  .word dofill
table32
  .word table33
  .byte "reg8", 0
  .word doreg8
table33
  .word table34
  .byte "reg!", 0
  .word doregset
table34
  .word $0000       ; signals last entry
  .byte "cls", 0
  .word docls


;;;
;;; SECTION 1: Low-level SPI code
;;;
;;;


;;;
;;; Wiring details:
;;;   CLK is PB0, ie 1
;;;   MOSI is PB1, ie 2
;;;   CS is PB2, ie 4
;;;   MISO is PB7, which maps onto S flag on BIT (test with BPL and BMI)
;;; MISO, MOSI, and CS all have pull-up resisters, so they are high in
;;; the idle/unused state, except when pulled low by active circuitry.
;;;
;;; For the moment, this is the same setup as the SD card reader.
;;; Since I want to be able to set things up for keyboard input on
;;; on the same port, I'm likely to want to move some of the lines
;;; around later. However, for now, I wannt to use validated code.
;;;
;;; Other bits:
;;;    BACKLIGHT  PB3, ie 8
;;;    BUSY       PB4, ie 16
;;;    RESET      PB5, ie 32
;;;
;;; Device is SPI Mode 0. This means:
;;;   clock idles low
;;;   clock active high
;;;   data read on rising edge

SPI_CLK  = 1
SPI_MOSI = 2
SPI_CS   = 4
LIGHT    = 8
SPI_MISO = 128
BUSYMASK = 16
RESET    = 32

;;; set up data direction for SPI_PORT -- bits 0, 1, 2, 3, and 5 are
;;; outputs and bits 4, 6 (NC), and 7 are inputs.
setup6522
  lda #$2f
  sta UVIA_DDRB
  lda #SPI_MOSI|RESET|SPI_CS
  sta SPI_PORT
  rts


;;; Send a byte via SPI. This faster version of the original code
;;; unrolls the loop and relies on shifts rather than branches to
;;; determine the bit to send. This is written on the assumption
;;; that the CLK signal idles low.
;;;
sendbyte
  phy
  ;tay               ; y will store the data as we transmit it

; bit 7
  ;tya
  asl               ; moves bit to transmit into C (2 cycles)
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #2            ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles
  ;; NOTE used to have "dec SPI_PORT" right after the inc but I
  ;; moved it down to even out the duty cycle. I strongly suspect
  ;; that this is completely irrelevant. Once everything is working,
  ;; try moving it back since the code reads better in its original
  ;; configuration.

; bit 6
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 5
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 4
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 3
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 2
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 1
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 0
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

  ;; set MOSI high at end
  lda #SPI_MOSI
  tsb SPI_PORT

  dec SPI_PORT      ; 6 cycles

  ply
  rts


getresponse
.(
  phx
  ldx #0
loop
  inx
  beq timedout
  jsr recv8bits
  cmp #$ff
  beq loop
timedout
  plx
  rts
.)

;;; read a byte via SPI from SPI_PORT, returned in accumulator.
;;; Assume the CLK idles low.
recv8bits
  phx               ; store X, since we'll use it (and can't use Y)
  lda #0            ; zero out initial result

  inc SPI_PORT      ; set CLK high for first bit
  ldx SPI_PORT      ; read data
  cpx #128          ; this sets carry flag to top bit
  rol               ; shift carry into A
  dec SPI_PORT      ; set clock off

  inc SPI_PORT      ; set CLK high #2
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #3
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #4
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #5
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #6
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #7
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #8
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  plx               ; restore X
  rts               ; return with data in A


;;;
;;; SECTION 2: Read and set RA8875 registers
;;;
;;;

;;; poll the WAIT flag until it goes high
awaitfree
;  pha
;waitloop
;  lda SPI_PORT
;  and #BUSYMASK
;  beq waitloop
;  pla
  rts

wrcommand
  pha               ; cache value

;  lda #SPI_CS       ; set CS to low
;  trb SPI_PORT
  lda #RESET        ; everything low except RESET
  sta SPI_PORT

  lda #CMDWRITE     ; send CMDWRITE
  jsr sendbyte
  pla               ; retreive value
  jsr sendbyte      ; send it

;  lda #SPI_MOSI     ; set MOSI high
;  tsb SPI_PORT

;  lda #SPI_CS       ; set CS high
;  tsb SPI_PORT
  lda #SPI_MOSI|SPI_CS|RESET
  sta SPI_PORT
  rts

;rdcommand
;  lda #SPI_CS       ; set CS low
;  trb SPI_PORT
;
;  ;; send CMDREAD
;  lda #CMDREAD      ; send CMDREAD
;  jsr sendbyte
;  jsr getresponse   ; receive data into A
;
;  pha               ; cache it temporarily
;  lda #SPI_CS       ; set CS high
;  tsb SPI_PORT
;  pla               ; retrieve data
;  rts

wrdata
  pha
;  ;; set CS low
;  lda #SPI_CS
;  trb SPI_PORT
  lda #RESET        ; everything low except RESET
  ;; send DATAWRITE
  lda #DATAWRITE
  jsr sendbyte
  pla
  ;; send A
  jsr sendbyte
;  ;; set MOSI high
;  lda #SPI_MOSI
;  tsb SPI_PORT
;  ;; set CS high
;  lda #SPI_CS
;  tsb SPI_PORT
  lda #SPI_MOSI|SPI_CS|RESET   ; CS, MOSI, RESET high
  sta SPI_PORT
  rts

rddata
;  lda #SPI_CS       ; set CS low
;  trb SPI_PORT
  lda #RESET
  sta SPI_PORT      ; RESET high, everything else low

  lda #DATAREAD     ; send DATAREAD
  jsr sendbyte

;  lda #SPI_MOSI     ; keep MOSI low while awaiting response
;  trb SPI_PORT
  lda #RESET
  sta SPI_PORT      ; RESET high, everything else low

  jsr recv8bits     ; get response into A
  pha               ; cache it for a moment

;  lda #SPI_MOSI     ; set MOSI high
;  tsb SPI_PORT
;  lda #SPI_CS       ; set CS high
;  tsb SPI_PORT
  lda #SPI_MOSI|SPI_CS|RESET
  sta SPI_PORT

  pla               ; retreive data
  rts

;; write value in Y to register in A
writereg
  jsr wrcommand
  tya
  jsr wrdata
  rts

readreg
  jsr wrcommand
  jsr rddata
  rts
  


;;;
;;; SECTION 3: Control RA8875 functions
;;;
;;;

;;; Initialize video processor
;;;
vidinit
  ;; initial setup -- CLOCK high, MOSI high, RESET high, CS high
  lda #SPI_CLK|SPI_MOSI|RESET|SPI_CS
  sta SPI_PORT

  ;; for reset -- hold RESET, CLK, and MOSI all low
  ;; that's basically everything except MISO, right?
  lda #SPI_MISO
  sta SPI_PORT
  ;; short pause
  jsr delay100ms
  ;; set RESET, CLK, MOSI and CS all high
  lda #RESET|SPI_CLK|SPI_MOSI|SPI_CS
  sta SPI_PORT
  jsr delay100ms

  ;; now set chip select low (and leave it there)
  lda #RESET|SPI_CLK|SPI_MOSI
  sta SPI_PORT


  ;; check things are okay -- read status register and confirm value
  lda #0
  jsr wrcommand
  jsr rddata
  cmp #$75
  beq endvidinit
fail
  jsr putax
  lda #<failstr
  sta PRINTVEC
  lda #>failstr
  sta PRINTVEC+1
  jsr printvecstr
endvidinit  
  rts

successstr .byte "reg 0 read successful", $0a, $0d, $0
failstr    .byte " != 0x75", $0a, $0d, $0


;;; Initialize registers to default settings
;;;
reginit
  lda #PLLC1
  ldy #PLLC1_PLLDIV1+11
  jsr writereg
  jsr delay1ms

  lda #PLLC2
  ldy #PLLC2_DIV4
  jsr writereg
  jsr delay1ms

  lda #SYSR
  ldy #SYSR_16BPP|SYSR_MCU8
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #PCSR
  ldy #PCSR_PDATL|PCSR_2CLK
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #HDWR
  ldy #99
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #HNDFTR
  ldy #HNDFTR_DE_HIGH
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #HNDR
  ldy #3
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #HSTR
  ldy #3
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #HPWR
  ldy #HPWR_LOW+11
  jsr writereg
  jsr delay1ms

  ;; vertical settings registers
  ;jsr awaitfree
  lda #VDHR0
  ldy #<479
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #VDHR1
  ldy #>479
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #VNDR0
  ldy #31
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #VNDR1
  ldy #0
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #VSTR0
  ldy #22
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #VSTR1
  ldy #0
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #VPWR
  ldy #VPWR_LOW+1
  jsr writereg
  jsr delay1ms


  ;; active window X

  ;jsr awaitfree
  lda #HSAW0
  ldy #0
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #HSAW1
  ldy #0
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #HEAW0
  ldy #<799
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #HEAW1
  ldy #>799
  jsr writereg
  jsr delay1ms

  ;; active window Y
  ;jsr awaitfree
  lda #VSAW0
  ldy #0
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #VSAW1
  ldy #0
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #VEAW0
  ldy #<479
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #VEAW1
  ldy #>479
  jsr writereg
  jsr delay1ms

  ;jsr awaitfree
  lda #MCLR
  ldy #MCLR_START|MCLR_FULL
  jsr writereg

  jsr delay1s

  rts


do20reg
  ldy #0
regloop
  tya
  jsr wrcommand
  jsr rddata
  jsr putax
  lda #32
  jsr puta
  iny
  cpy #20
  bne regloop
  jsr crlf
  rts
  


doreg0
  lda #0
  jsr wrcommand
  jsr rddata
  jsr putax
  jsr crlf
  rts


;;; Turn on display and backlight
;;;
displayon

  ;tft.displayOn(true);
  lda #PWRR
  ldy #PWRR_NORMAL|PWRR_DISPON
  jsr writereg
  
  ; tft.GPIOX(true);      // Enable TFT - display enable tied to GPIOX
  lda #GPIOX
  ldy #1
  jsr writereg

  ; tft.PWM1config(true, RA8875_PWM_CLK_DIV1024); // PWM output for backlight
  lda #P1CR
  ldy #P1CR_ENABLE|PWM_CLK_DIV1024
  jsr writereg
  
  ;tft.PWM1out(255);
  lda #P1DCR
  ldy #255
  jsr writereg

  rts

doon
  ; tft.PWM1config(true, RA8875_PWM_CLK_DIV1024); // PWM output for backlight
  lda #P1CR
  ldy #P1CR_ENABLE|PWM_CLK_DIV1024
  jsr writereg
  
  ;tft.PWM1out(255);
  lda #P1DCR
  ldy #255
  jsr writereg
  rts

dooff
  lda #P1CR
  ldy #P1CR_ENABLE|PWM_CLK_DIV1024
  jsr writereg
  
  lda #"d
  jsr puta
  
  lda #P1DCR
  ldy #0
  jsr writereg
  rts

;;; Mess around with the backlight/PWM setting?
;;;
dopwm
  phx
  ldx #5
  txa
pwmloop
  tay
  lda #P1DCR
  jsr writereg
  ldy #255
pwmdelay
  dey
  bne pwmdelay
  txa
  clc
  adc #5
  tax
  cmp #255
  bne pwmloop
  plx
  rts

;;; Look up current PWM setting
;;;
dopwmq
  lda #P1DCR
  jsr wrcommand
  jsr rddata
  jsr putax
  jsr crlf
  rts


;;; set text colors (actually, either mode) -- fg white, bg black
;;;
defaultcolors

  ;; set foreground to white
  jsr awaitfree
  lda #$63
  ldy #$1f
  jsr writereg

  lda #$64
  ldy #$3f
  jsr writereg

  lda #$65
  lda #$1f
  jsr writereg

  ldy#0
  lda #$60
  jsr writereg
  lda #$61
  jsr writereg
  lda #$62
  jsr writereg
  
  ;; Clear transparency flag
  lda #$22
  jsr wrcommand
  jsr rddata
  and #%10111111    ; clear bit 6
  jsr wrdata

  rts


;;;
;;;
;;; MAIN CODE ENTRY POINT -- initialize and start main loop
;;;
;;;

start

  ;; initialization?
  ;;

  phx               ; preserve x, since it's our private stack pointer
                    ; only valuable if we ever return of course

  jsr setup6522     ; set up the port

  jsr primm
  .byte "SPIV Video tester", $0d, $0a, $00
  jsr dohelp        ; print the commands
  jsr doinit        ; initialize the video board
  jsr dotext        ; set text mode
  jsr docursor      ; turn on cursor


;;;
;;;
;;; SECTION 4: Command line interpreter
;;;
;;;

reploop
.(
  ;; print the prompt
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda prompt
  sta ACIA_DATA
.)

  jsr readline      ; read a line into INPUT
  jsr crlf          ; echo line feed/carriage return

  ;; nothing entered? loop again
  cpy #0
  beq reploop

  ;; parse and process the command line
  ;;
  lda #0           
  sta INPUT,y       ; null-terminate the string
  jsr parseinput    ; parse into individual arguments, indexed at ARGINDEX
  jsr matchcommand  ; match input command and execute
  jmp reploop       ; loop around


parseinput
  ldx #0
  ldy #0

.(
;; look for non-space
nextchar
  lda INPUT,x
  cmp #32
  bne nonspace
  inx
  jmp nextchar

;; mark the start of the word
nonspace
  iny               ; maintain a count of words in y
  stx ARGINDEX,y
;; look for space
lookforspace
  inx
  lda INPUT,x
  beq endofline     ; check for null termination
  cmp #32           ; only looking for spaces. Tab?
  beq endofword
  jmp lookforspace
;; didn't hit a terminator, so there must be more.
;; terminate this word with a zero and then continue
endofword
  lda #0
  sta INPUT,x         ; null-terminate
  inx
  jmp nextchar        ; repeat
endofline
  ;; we're done
  ;; cache the arg count
  sty ARGINDEX

  rts
.)


;;;
;;; Command lookup and dispatch. Search the table for a string that
;;; matches the command entered. If it is found, jump to it. ENTRY
;;; points to the current entry in the table as we step through the
;;; list of commands.
;;;
;;; This is called as a subroutine. We jump to the code, so an rts
;;; from there will return to the interpeter loop; if we hit an error,
;;; we rts from here with the same effect.
;;;

matchcommand
  lda #<table    ; low byte of table address
  sta ENTRY
  lda #>table    ; high byte of table address
  sta ENTRY+1

testentry
cacheptr
  ;; grab the pointer to the next entry and cache it in scratchpad
  ldy #0
  lda (ENTRY),Y  ; first byte
  sta SCRATCH
  iny
  lda (ENTRY),Y  ; second byte
  sta SCRATCH+1
  iny
  ldx #0         ;; will use X and Yas index for string
.(
nextchar
  lda INPUT,x
  beq endofword
  cmp (ENTRY),y
  bne nextentry
  inx
  iny
  jmp nextchar
.)

endofword
  ;; we got here because we hit the end of the word in the buffer
  ;; if it's also the end of the entry label, then we've found the right place
  lda (ENTRY),y
  beq successful
  ;; but if it's not, then we haven't.
  ;; continue to the next entry
  jmp nextentry

successful
  ;; we got a match! copy out the destination address, jump to it
  iny
  lda (ENTRY),Y
  sta SCRATCH+2
  iny
  lda (ENTRY),Y
  sta SCRATCH+3
  jmp (SCRATCH+2)
  rts  ;; never get here -- we rts from the command code
    
nextentry
  lda SCRATCH           ;; copy the address of next entry from scratchpad
  sta ENTRY
  lda SCRATCH+1
  sta ENTRY+1
  ;; test for null here
  ora SCRATCH       ;; check if the entry was $0000
  beq endoftable    ;; if so, we're at the end of table
  jmp testentry

endoftable
  ;; got to the end of the table with no match
  ;; print an error message, and return to line input
  ;; ...

printerror
  lda #<nocmderrstr
  sta PRINTVEC
  lda #>nocmderrstr
  sta PRINTVEC+1
  jsr printvecstr
  rts



;;;
;;; SECTION 5: Implement interpreter commands
;;;
;;;

;;; Print help information. The old version of this used to just
;;; print a string; for easier reuse, this version walks the command
;;; table and prints out each entry.
dohelp
.(
  jsr primm
  .byte "Commands: ", 0

  lda #<table       ; start at beginning of table
  sta SCRATCH       ; SCRATCH and SCRATCH+1 are table pointer
  lda #>table
  sta SCRATCH+1

nextcmd
  ldy #1            ; grab a copy of pointer to next entry
  lda (SCRATCH)     ; and cache it in SCRATCH+2/3
  sta SCRATCH+2
  lda (SCRATCH),y
  sta SCRATCH+3

  clc               ; set PRINTVEC to the name entry in the table
  lda SCRATCH       ; two bytes after start of entry
  adc #2
  sta PRINTVEC
  lda SCRATCH+1
  adc #0
  sta PRINTVEC+1
  jsr printvecstr   ; print command name

  lda SCRATCH+2     ; check if this is the end of the table
  ora SCRATCH+3     ; signalled by zero as pointer to next entry
  beq endhelp

  lda #$2c          ; otherwise, there's another entry so print comma
  jsr puta          ; and space
  lda #32
  jsr puta

  lda SCRATCH+2     ; move pointer to next table entry
  sta SCRATCH
  lda SCRATCH+3
  sta SCRATCH+1
  bra nextcmd       ; loop

endhelp
  jsr crlf
  rts
.)


;;; Echo text from command line to display
;;;
doecho
  phx
  lda #MRWC
  jsr wrcommand
.(
  ldy #1                  ; start at 1 because we ignore the command itself
echonext
  cpy ARGINDEX            ; have we just done the last?
  beq end                 ; yes, so end
  iny                     ; no, so move on to the next
  ldx ARGINDEX,y
  ;; not using printvecstr for this because we're printing
  ;; directly out of the input buffer  
next_char
  lda INPUT,x
  beq endofarg
  jsr puta
  jsr wrdata
  inx
  jmp next_char
endofarg
  lda #32                  ; put a space at the end
  jsr puta
  jsr wrdata
  jmp echonext
end

  jsr crlf
  plx                      ; restore the stack pointer
  rts
.)


;;; Quit program
;;;
doquit
  pla               ; drop the most recent return address
  pla               ; so that we will return instead to the monitor
  plx               ; restore the FORTH stack pointer
  rts               ; exit


;;; Initialize the display
;;;
doinit
  jsr primm
  .byte "initializing RA8875...", $0a, $0d, $0
  jsr vidinit

  jsr primm
  .byte "initializing registers...", $0a, $0d, $0
  jsr reginit

  jsr primm
  .byte "turning display on...", $0a, $0d, $0
  jsr displayon
  
  rts


dovinit
  jsr vidinit
  rts

doreginit
  jsr reginit
  rts

dodisplay
  jsr displayon
  rts

DLSTART=$80
DLSTOP=$00
DRAWSQUARE=$10
FILL=$20

;;; Look up current fg color values
;;;
docolorq
  lda #$63
  jsr wrcommand
  jsr rddata
  jsr putax
  lda #32
  jsr puta

  lda #$64
  jsr wrcommand
  jsr rddata
  jsr putax
  lda #32
  jsr puta

  lda #$65
  jsr wrcommand
  jsr rddata
  jsr putax
  jsr crlf

  rts

setwhite
  lda #$63
  jsr wrcommand

  ;writeData((color & 0xf800) >> 11)
  lda #$1f
  jsr wrdata

  lda #$64
  jsr wrcommand

  ;writeData((color & 0x07e0) >> 5)
  lda #$3f
  jsr wrdata

  lda #$65
  jsr wrcommand
  ;writeData((color & 0x001f))
  lda #$1f
  jsr wrdata
  rts
  

setred
  lda #$63
  jsr wrcommand

  ;writeData((color & 0xf800) >> 11)
  lda #$1f
  jsr wrdata

  lda #$64
  jsr wrcommand

  ;writeData((color & 0x07e0) >> 5)
  lda #0
  jsr wrdata

  lda #$65
  jsr wrcommand
  ;writeData((color & 0x001f))
  lda #0
  jsr wrdata
  rts
  

setblue
  lda #$63
  jsr wrcommand

  ;writeData((color & 0xf800) >> 11)
  lda #0
  jsr wrdata

  lda #$64
  jsr wrcommand

  ;writeData((color & 0x07e0) >> 5)
  lda #0
  jsr wrdata

  lda #$65
  jsr wrcommand
  ;writeData((color & 0x001f))
  lda #$1f
  jsr wrdata
  rts
  

;;; fill screen with the current foreground color
;;;
fillscreen
  ;; set up parameters -- startx, starty, endx, endy
  lda #$91
  ldy #0
  jsr writereg
  ldy #0
  lda #$92
  jsr writereg
  ldy #0
  lda #$93
  jsr writereg
  ldy #0
  lda #$94
  jsr writereg

  lda #$95
  ldy #$1F          ; lower byte for 799
  jsr writereg
  lda #$96
  ldy #03           ; upper byte for 799
  jsr writereg

  lda #$97
  ldy #$df          ; lower byte for 479
  jsr writereg
  lda #$98          
  ldy #$01          ; upper byte for 479
  jsr writereg

  lda #DCR
  jsr wrcommand
  
  lda #DLSTOP|DRAWSQUARE
  jsr wrdata
  lda #DLSTART|FILL|DRAWSQUARE
  jsr wrdata
  rts

;;; draw a filled rectangle, presuming that it's already all set up
fillrect
  lda #DCR
  jsr wrcommand
  
  lda #DLSTOP|DRAWSQUARE
  jsr wrdata
  lda #DLSTART|FILL|DRAWSQUARE
  jsr wrdata

  jsr delay100ms
  rts


dowhite
  jsr primm
  .byte "Setting white", $0d, $0a, $0
;  jsr setwhite
;  jsr fillscreen
  lda #7
  jsr fillcolor
  rts
  
doblue
  jsr primm
  .byte "Setting blue", $0d, $0a, $0
;  jsr setblue
;  jsr fillscreen
  lda #3
  jsr fillcolor
  rts
  
dored
  jsr primm
  .byte "Setting red", $0d, $0a, $0
;  jsr setred
;  jsr fillscreen
  lda #1
  jsr fillcolor
  rts

;;; fill the screen with the color from the color table specified in
;;; the accumulator. Set color back to current setting afterwards.
;;;
fillcolor
  sta SCRATCH       ; temporarily store color
  
  ;; look up current color values and save them
  lda #$63
  jsr wrcommand
  jsr rddata
  pha

  lda #$64
  jsr wrcommand
  jsr rddata
  pha

  lda #$65
  jsr wrcommand
  jsr rddata
  pha

  ;; set fg color
  lda SCRATCH
  jsr setfg

  ;; fill screen
  jsr fillscreen
  jsr delay100ms    ; BUG should poll register to determine readiness

  ;; reset color
  pla
  tay
  lda #$65
  jsr writereg
  pla
  tay
  lda #$64
  jsr writereg
  pla
  tay
  lda #$63
  jsr writereg
  rts

;;; set foreground color to values from color table indexed by A
;;;
setfg
  sta SCRATCH       ; cache A then multiply by 3
  asl               ; = *2
  clc
  adc SCRATCH       ; = *3
  sta SCRATCH       ; store it because I can't rely on Y

  ldy SCRATCH       ; load the offset
  lda colors,y      ; load color value at offset
  tay               ; move to Y
  lda #$63          ; register to A
  jsr writereg      ; store Y in A
  inc SCRATCH       ; move on to next value

  ldy SCRATCH       ; load the offset
  lda colors,y      ; load color value at offset
  tay               ; move to Y
  lda #$64          ; register to A
  jsr writereg      ; store Y in A
  inc SCRATCH       ; move on to next value

  ldy SCRATCH       ; load the offset
  lda colors,y      ; load color value at offset
  tay               ; move to Y
  lda #$65          ; register to A
  jsr writereg      ; store Y in A

  rts

;;; set background color to values from color table indexed by A
;;;
setbg
  sta SCRATCH       ; cache A then multiply by 3
  asl               ; = *2
  clc
  adc SCRATCH       ; = *3
  sta SCRATCH       ; store it because I can't rely on Y

  ldy SCRATCH       ; load the offset
  lda colors,y      ; load color value at offset
  tay               ; move to Y
  lda #$60          ; register to A
  jsr writereg      ; store Y in A
  inc SCRATCH       ; move on to next value

  ldy SCRATCH       ; load the offset
  lda colors,y      ; load color value at offset
  tay               ; move to Y
  lda #$61          ; register to A
  jsr writereg      ; store Y in A
  inc SCRATCH       ; move on to next value

  ldy SCRATCH       ; load the offset
  lda colors,y      ; load color value at offset
  tay               ; move to Y
  lda #$62          ; register to A
  jsr writereg      ; store Y in A

  rts

;;; print current text cursor position
;;;
dopos
  lda #$2b
  jsr readreg
  jsr putax
  lda #$2a
  jsr readreg
  jsr putax
  lda #",
  jsr puta
  lda #$2d
  jsr readreg
  jsr putax
  lda #$2c
  jsr readreg
  jsr putax
  jsr crlf
  rts

;;; move to the start of a new line. set horizontal position to zero, and
;;; increment vertical position by 16. (NOTE: this presumes that we're
;;; at text size 0.)
;;;
donewline
  ;; first, do the equivalent of a carriage return
  ldy #0            ; set $2a and $2b, horizontal position, to 0
  lda #$2b
  jsr writereg
  lda #$2a
  jsr writereg

  ;; second, do the equivalent of a line feed
  lda #$2d          ; read MSB of vertical position
  jsr readreg
  tay               ; cache it in Y
  lda #$2c          ; read LSB of vertial position
  jsr readreg
  clc
  adc #16           ; add 16
  pha               ; temporaily store on stack
  tya               ; get MSB again
  adc #0            ; process the carry
  tay               ; write to Y
  lda #$2d          ; write value of Y to $2d (MSB)
  jsr writereg
  ply               ; retreive LSB cached on stack
  lda #$2c          ; write to LSB register
  jsr writereg
  rts


;;; test the scrolling window mechanism
;;;
dosetscroll
  jsr primm
  .byte "setting up scroll window", $0a, $0d, $0
  
  ;; set up parameters -- startx, starty, endx, endy
  ;; the scroll window should be the entire display, so 0,0 - 799,479
  lda #$38
  ldy #0
  jsr writereg
  ldy #0
  lda #$39
  jsr writereg
  ldy #0
  lda #$3a
  jsr writereg
  ldy #0
  lda #$3b
  jsr writereg

  lda #$3c
  ldy #$1F          ; lower byte for 799
  jsr writereg
  lda #$3d
  ldy #03           ; upper byte for 799
  jsr writereg

  lda #$3e
  ldy #$df          ; lower byte for 479
  jsr writereg
  lda #$3f
  ldy #$01          ; upper byte for 479
  jsr writereg
  rts

;;; test the scrolling window mechanism
;;;
dounsetscroll
  jsr primm
  .byte "setting scroll window to zero", $0a, $0d, $0
  
  ;; set up parameters -- startx, starty, endx, endy
  ;; the scroll window should be the entire display, so 0,0 - 799,479
  ldy #0
  lda #$38
  jsr writereg
  lda #$39
  jsr writereg
  lda #$3a
  jsr writereg
  lda #$3b
  jsr writereg

  lda #$3c
  jsr writereg
  lda #$3d
  jsr writereg
  lda #$3e
  jsr writereg
  lda #$3f
  jsr writereg
  rts

doscroll
  jsr primm
  .byte "scrolling window by increments", $0a, $0d, $0

  ldy #0
  lda #$27
  jsr writereg
scrollloop
  tya
  jsr putax
  tay
  lda #32
  jsr puta
  lda #$26
  jsr writereg
  phy
  ldy #0
  lda #$27
  jsr writereg      ; do i need to write both registers?
  jsr delay100ms
  ply
  tya
  clc
  adc #16
  tay
  beq endscroll
  tay
  bra scrollloop
endscroll
  jsr crlf
  rts


;;; clear screen
;;;
docls
  ;; fill the screen with black
  lda #0            ; color 0 is black
  jsr fillcolor

  ;; reset the text position
  ldy #0
  lda #$2a
  jsr writereg
  ldy #0
  lda #$2b
  jsr writereg
  ldy #0
  lda #$2c
  jsr writereg
  lda #$2d
  ldy #0
  jsr writereg

  ;; reset the text color (already done?)
  rts


;;; set text mode, text font, text color, and text direction
;;;
dotext
  ;; wait until free
  jsr awaitfree

  ;; send command 0x40 (MWCR0 register)
  lda #$40
  jsr wrcommand

  ;; read response
  jsr rddata
  ;; set bit 7
  ora #$80
  ;; write it back as data
  jsr wrdata

  ;; font selection
  lda #$21
  jsr wrcommand
  jsr rddata
  and #%0101111     ; clear bits 7 and 5
  jsr wrdata

  jsr defaultcolors

  jsr primm
  .byte "text mode set", $0a, $0d, $00

  rts

dorw
  lda #".
  jsr puta
  lda #MWCR0
  jsr wrcommand
  lda #".
  jsr puta
  jsr rddata
  jsr putax
  jsr crlf
  rts

;;; Turn on hardware cursor
;;;
docursor
  lda #MWCR0
  jsr wrcommand
  jsr rddata
  ora #MWCR0_CURSOR
  jsr wrdata

  lda #MWCR0
  jsr wrcommand
  jsr rddata
  ora #MWCR0_BLINK
  jsr wrdata

  lda #BTCR
  jsr wrcommand
  lda #32           ; just keep tweaking until I like the result
  jsr wrdata

  jsr primm
  .byte "cursor enabled", $0a, $0d, $0
  rts


;;; add a load of text to the screen, for testing purposes
dofill
  jsr dofont
  jsr donewline
  lda #4
  jsr setfg
  jsr dofont
  jsr donewline
  lda #6
  jsr setfg
  jsr dofont
  jsr donewline
  lda #8
  jsr setfg
  jsr dofont
  jsr donewline

  lda #7
  jsr setfg
  jsr donewline
  jsr donewline
  jsr donewline
  jsr dohello
  jsr dohello
  jsr donewline
  jsr dohello
  jsr donewline
  jsr donewline
  jsr donewline
  jsr donewline
  jsr donewline
  jsr donewline

  jsr dofont
  jsr dofont
  jsr dofont
  jsr dofont
  jsr dofont
  jsr donewline

  jsr donewline
  jsr dofont
  jsr dofont
  jsr dofont
  jsr donewline

  jsr dosquares
  rts
  


dograph
  lda #MWCR0
  jsr wrcommand
  jsr rddata
  and #127       ; turn off bit 7
  jsr wrdata
  rts

;;; Display standardized "hello" message
;;; 
dohello
.(
  lda #MRWC
  jsr wrcommand
  ldy #0
strloop
  lda hellostr,y
  beq endstr
  jsr wrdata
  iny
  bra strloop
endstr
  rts
.)

hellostr .byte "Hello hello hello from the Mite/RA8875 ", $00


;;; add squares to the display. oddly, we can do this while we're in
;;; text mode, suggesting that I don't really get yet what the deal is
;;; with text mode vs graphics mode.
dosquares
  ;; one white square
  lda #7
  jsr setfg
  
  lda #20
  ldy #20
  jsr setsquarexy
  jsr fillrect

  ;; one red square
  lda #1
  jsr setfg
  
  lda #30
  ldy #20
  jsr setsquarexy
  jsr fillrect

  ;; one cyan square
  lda #4
  jsr setfg
  
  lda #40
  ldy #20
  jsr setsquarexy
  jsr fillrect

  ;; one yellow square
  lda #6
  jsr setfg
  
  lda #50
  ldy #20
  jsr setsquarexy
  jsr fillrect

  rts

;;; set parameters for a square. on entry, A and Y are the X and Y coordinates
;;; div 8 for the top left.
setsquarexy
  ;; first, cache the values
  sta SCRATCH
  stz SCRATCH+1
  sty SCRATCH+2
  stz SCRATCH+3

  ;; now shift both left three places
  asl SCRATCH
  rol SCRATCH+1
  asl SCRATCH
  rol SCRATCH+1
  asl SCRATCH
  rol SCRATCH+1

  asl SCRATCH+2
  rol SCRATCH+3
  asl SCRATCH+2
  rol SCRATCH+3
  asl SCRATCH+2
  rol SCRATCH+3

  ;; set up parameters -- startx, starty, endx, endy
  lda #$91
  ldy SCRATCH
  jsr writereg
  ldy SCRATCH+1
  lda #$92
  jsr writereg
  ldy SCRATCH+2
  lda #$93
  jsr writereg
  ldy SCRATCH+3
  lda #$94
  jsr writereg

  ;; add 60 to each value, for the end points
  clc
  lda SCRATCH
  adc #40
  sta SCRATCH
  lda SCRATCH+1
  adc #0
  sta SCRATCH+1

  lda SCRATCH+2
  adc #40
  sta SCRATCH+2
  lda SCRATCH+3
  adc #0
  sta SCRATCH+3

  lda #$95
  ldy SCRATCH
  jsr writereg
  lda #$96
  ldy SCRATCH+1
  jsr writereg

  lda #$97
  ldy SCRATCH+2
  jsr writereg
  lda #$98          
  ldy SCRATCH+3
  jsr writereg
  rts

light .byte 0

dolight
  lda light
  bne lightoff
  inc light
  lda #LIGHT
  tsb SPI_PORT
  rts
lightoff
  dec light
  lda #LIGHT
  trb SPI_PORT
  rts



;;; display a block of eight registers, starting from a base address
;;; specified on the command line (two hex digits).
doreg8

  ;; get the first parameter, if present
.(
  ldy #1
  cpy ARGINDEX
  bne continue
  jsr primm
  .byte "base address?", $0d, $0a, 0
  bra endreg8
continue
.)
  lda #1
  jsr readhexarg

  sta SCRATCH

  ldy #4
firstloop
  phy
  lda SCRATCH
  jsr putax
  lda #":
  jsr puta
  lda #32
  jsr puta
  lda SCRATCH
  jsr readreg
  jsr putax
  lda #32
  jsr puta
  jsr puta
  inc SCRATCH
  ply
  dey
  bne firstloop

  jsr crlf

  ldy #4
secondloop
  phy
  lda SCRATCH
  jsr putax
  lda #":
  jsr puta
  lda #32
  jsr puta
  lda SCRATCH
  jsr readreg
  jsr putax
  lda #32
  jsr puta
  jsr puta
  inc SCRATCH
  ply
  dey
  bne secondloop

  jsr crlf
  
endreg8
  rts

doregset
  ;; check paramters
.(
  ldy #2
  cpy ARGINDEX
  bne continue
  jsr primm
  .byte "address and value?", $0d, $0a, 0
  bra endreg8
continue
.)
  lda #1
  jsr readhexarg
  sta SCRATCH

  lda #2
  jsr readhexarg
  sta SCRATCH+1

  tay
  pla
  jsr writereg

  lda SCRATCH
  jsr putax
  lda #":
  jsr puta
  lda #32
  jsr puta
  lda SCRATCH+1
  jsr putax
  jsr crlf
  rts

;;; read a parameter (indicated by A) as a hex value (single byte)
;;; and return in A. Used by reg8 and regset.
readhexarg
  phx
  tay
  iny
  ldx ARGINDEX,y

  ;; load and process first digit. We're using SCRATCH+4 to assemble
  ;; the result
  lda INPUT,x
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra donefirst
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra donefirst
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
donefirst
  asl
  asl
  asl
  asl
  sta SCRATCH+4          ; assembling result here
.)

  ;; load and process second digit
  inx
  lda INPUT,x
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  jmp donesecond
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  jmp donesecond
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
donesecond
  clc
  adc SCRATCH+4
  sta SCRATCH+4     ; not needed I think?
.)
  
  plx
  rts


;;; Do a test text block move using bitblt functions. I think this
;;; is what I want to use to implement scrolling, so let's do something
;;; along those lines. Move roughly the bottom two third of the screen
;;; to the top of the screen, sticking to line-aligned units. There are
;;; 30 16-bit lines on a 480-line display, so basically I want to move
;;; (0,160)-(799,470) to (0,0)-(799,320).
;;;
domove
  ;; set up source address
  ;; NOTE address includes layer specification. I'm setting this
  ;; to zero, which means Layer 1. I'm not even sure right now which
  ;; layer I'm using!
  ldy #0            ; starting at 0, 160
  lda #$54          ; LSB of X coordinate
  jsr writereg
  lda #$55          ; MSB of X coordinate
  jsr writereg
  ldy #$A0          
  lda #$56          ; LSB of Y coordinate
  jsr writereg
  ldy #0
  lda #$57          ; MSB of Y coordinate
  

  ;; set up destination address
  ldy #0            ; copying to 0,0
  lda #$58          ; LSB of X coordinate
  jsr writereg
  lda #$59          ; MSB of X coordinate
  jsr writereg
  lda #$5A          ; LSB of Y coordinate
  jsr writereg
  lda #$5B          ; MSB of Y coordinate

  ;; set BTE width and hight
  ldy #$20          ; width is 800 ($320)
  lda #$5C          ; LSB of width
  jsr writereg
  ldy #$03
  lda #$5D          ; MSD of width
  jsr writereg


  ldy #$40          ; height is 340 ($140)
  lda #$5E          ; LSB of X coordinate
  jsr writereg
  ldy #$01
  lda #$5F          ; MSD of X coordinate
  jsr writereg

  ;; set BTE function
  ;; function is "move in a positive direction". The "positive direction"
  ;; means that we start at the beginning and move toward the end; since
  ;; the source and destination regions overlap, that's what we need.
  ;; ROP is "destionation = source" (ie, straight copy).
  ;; ROP is %1100 = $C, ROP is %0010 = $02
  ;; result is $C2
  ldy #$C2
  lda #$51
  jsr writereg

  ;; enable BTE function
  ldy #$80
  lda #$50
  jsr writereg


  ;; we really need to wait to determine when the operation has
  ;; has completed. For the moment, ignore this since I'm using a
  ;; CLI. BUG BUG BUG.

  rts

dofinish

  lda #$63
  jsr wrcommand
  jsr rddata
  pha

  lda #$64
  jsr wrcommand
  jsr rddata
  pha

  lda #$65
  jsr wrcommand
  jsr rddata
  pha

  ;; now set color to black, ready for painting the block
  ldy #0
  lda #$63
  jsr writereg
  lda #$64
  jsr writereg
  lda #$65
  jsr writereg

  ;; now stage two -- empty bottom third of the screen. region is
  ;; from ($0, $140) to ($31F, $11F)

  ;; set up parameters -- startx, starty, endx, endy
  lda #$91
  ldy #0
  jsr writereg
  ldy #0
  lda #$92
  jsr writereg
  ldy #$40
  lda #$93
  jsr writereg
  ldy #1
  lda #$94
  jsr writereg

  lda #$95
  ldy #$1F          ; lower byte for 799
  jsr writereg
  lda #$96
  ldy #03           ; upper byte for 799
  jsr writereg

  lda #$97
  ldy #$df          ; lower byte for 479
  jsr writereg
  lda #$98          
  ldy #$01          ; upper byte for 479
  jsr writereg

  lda #DCR
  jsr wrcommand
  
  lda #DLSTOP|DRAWSQUARE
  jsr wrdata
  lda #DLSTART|FILL|DRAWSQUARE
  jsr wrdata

  ;; add a pause to complete
  jsr delay100ms

  ;; reset color
  pla
  tay
  lda #$65
  jsr writereg
  pla
  tay
  lda #$64
  jsr writereg
  pla
  tay
  lda #$63
  jsr writereg

  ;; move text cursor
  ldy #0            ; set $2a and $2b, horizontal position, to 0
  lda #$2a
  jsr writereg
  lda #$2b
  jsr writereg
  ldy #$40
  lda #$2c
  jsr writereg
  ldy #1
  lda #$2d
  jsr writereg

  rts



;;; scrollup is basically the text scrolling function that i need
;;; for "terminal" type interaction. Four steps -- first, some setup
;;; that I do here so that the block transfer and then erase happen
;;; as quickly together as possible. Then, do the block transfer to
;;; move the bottom two thirds of the screen to the top. Next, paint
;;; a black background in the bottom third. Finally, reset the color
;;; and move the text position to the newly opened area.

doscrollup
  ;; set up for move. I do this out of line so that the actual transfer
  ;; happens as quickly as it can. Look up the current foreground
  ;; color, cache it on the stack, and set the foreground to black.
  ;; look up current color values and save them
  lda #$63
  jsr readreg
  pha

  lda #$64
  jsr readreg
  pha

  lda #$65
  jsr readreg
  pha

  ;; now set color to black, ready for painting the block after the move
  ldy #0
  lda #$63
  jsr writereg
  lda #$64
  jsr writereg
  lda #$65
  jsr writereg

  ;; setup completed. next, do the block move.
  jsr domove        ; this is where the block transfer happens

  ;; wait for block transfer to complete. Read register $50 until
  ;; the top bit is clear.
.(
busyloop
  lda #$50
  jsr readreg
  bmi busyloop
.)

  ;; now, empty bottom third of the screen. region is from
  ;; ($0, $140) to ($31F, $11F)

  ;; set up parameters -- startx, starty, endx, endy
  lda #$91
  ldy #0
  jsr writereg
  ldy #0
  lda #$92
  jsr writereg
  ldy #$40
  lda #$93
  jsr writereg
  ldy #1
  lda #$94
  jsr writereg

  lda #$95
  ldy #$1F          ; lower byte for 799
  jsr writereg
  lda #$96
  ldy #03           ; upper byte for 799
  jsr writereg

  lda #$97
  ldy #$df          ; lower byte for 479
  jsr writereg
  lda #$98          
  ldy #$01          ; upper byte for 479
  jsr writereg

  ;; do the block draw
  lda #DCR
  jsr wrcommand
  
  lda #DLSTOP|DRAWSQUARE
  jsr wrdata
  lda #DLSTART|FILL|DRAWSQUARE
  jsr wrdata

  ;; add a pause to complete
  jsr delay100ms

  ;; reset color. I should check if there's a way to draw a
  ;; rectangle using the current *background* color 'cos that
  ;; would be a lot easier!
  pla
  tay
  lda #$65
  jsr writereg
  pla
  tay
  lda #$64
  jsr writereg
  pla
  tay
  lda #$63
  jsr writereg

  ;; move text cursor
  ldy #0            ; set $2a and $2b, horizontal position, to 0
  lda #$2a
  jsr writereg
  lda #$2b
  jsr writereg
  ldy #$40
  lda #$2c
  jsr writereg
  ldy #1
  lda #$2d
  jsr writereg

  rts


;;; continually take input from the keyboard and output it on the
;;; screen. doesn't echo newline, but keeps track of how many
;;; lines we have entered so that it knows when to scroll.
doinput
  jsr primm
  .byte "Enter text, ctrl-X to exit", $0a, $0d, $0

  stz SCRATCH       ; maintain line count
startinput
  lda #MRWC
  jsr wrcommand

inputloop
  jsr geta
  cmp #24    ; ^x
  beq endinput
  cmp #$0d
  beq endofline

  jsr wrdata
  bra inputloop

endofline
  inc SCRATCH
  lda SCRATCH
  cmp #30           ; end of screen
  beq endofscreen
  jsr donewline
  bra startinput

endofscreen
  jsr doscrollup
  lda #20
  sta SCRATCH
  bra startinput

endinput
  rts


;;; Set text size (range 0-3)
;;;
dosize
  phx

  ;; get the first parameter, if present
  ldy #1
  cpy ARGINDEX
  beq endsize
  iny
  ldx ARGINDEX,y
  lda INPUT,x

  ;; assuming it's a single digit, convert to a number
  sec
  sbc #"0
  cmp #3
  beq setsize
  bmi setsize
  lda #3

setsize
  ;; set register
  tay
  lda #$22          ; $22 = FNCR1
  jsr wrcommand
  jsr rddata

  and #$f0          ; clear bits 0-3
  sta SCRATCH
  tya
  asl               ; or with scale << 2 (horizontal)
  asl
  ora SCRATCH
  sta SCRATCH
  tya               ; then or with scale (vertical)
  ora SCRATCH
  sta SCRATCH

  jsr wrdata

endsize
  plx
  rts


;;; display the font (characters 0x20-0x7f)
;;;
dofont
  lda #MRWC
  jsr wrcommand
  ldy #31
fontloop
  iny
  cpy #$80
  beq endfont
  tya
  jsr wrdata
  bra fontloop
endfont
  rts


;;; set foreground color
dofg
  phx

  ;; get the first parameter, if present
  ldy #1
  cpy ARGINDEX
  beq endsize
  iny
  ldx ARGINDEX,y
  lda INPUT,x

  ;; assuming it's a single digit, convert to a number
  sec
  sbc #"0

  ; set color
  jsr setfg

  plx
  rts

;;; set foreground color
dobg
  phx

  ;; get the first parameter, if present
  ldy #1
  cpy ARGINDEX
  beq endsize
  iny
  ldx ARGINDEX,y
  lda INPUT,x

  ;; assuming it's a single digit, convert to a number
  sec
  sbc #"0

  ; set color
  jsr setbg

  plx
  rts

;;; color lookup table
;;; RA8875 uses five bits for blue, six for green, and five for red.
;;; Rather than extract them from 16-bit values, I've just precomputed
;;; some colors here and can use index into this table as a color value.
;;; color 0 = black, color 8 = white, and the others are a random selection.
colors
  .byte $00, $00, $00    ; black
  .byte $1F, $00, $00    ; red
  .byte $00, $3F, $00    ; green
  .byte $00, $00, $1F    ; blue
  .byte $00, $3F, $1F    ; cyan
  .byte $1F, $00, $1F    ; magenta
  .byte $1F, $3F, $00    ; yellow
  .byte $1F, $3F, $1F    ; white
  .byte $0F, $1F, $0F    ; grey
  .byte $1D, $18, $15    ; pink?


;;;
;;; SECTION 6: Various utility routines
;;;
;;;

;;;
;;; Ouptut carriage return and line feed to serial port
;;;
crlf
  pha
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0d
  sta ACIA_DATA
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0a
  sta ACIA_DATA
  pla
  rts


;;;
;;; output the character code in the accumulator to the serial port
;;;
puta
.(
  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts

;;;
;;; get a character code via serial port, left in the accumulator
;;;
geta
.(
wait_rxd_empty
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_empty
  lda ACIA_DATA
.)
  rts

;;;
;;; output the value in the accumulator as a hex pattern to serial port
;;; NB x cannot be guaranteed to be stack ptr during this... check...
;;;
putax
.(
  pha
  phy

  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  pha             ; put a copy back
  clc
  and #$f0
  ror
  ror
  ror
  ror
  tay
  lda hextable,y
  sta ACIA_DATA
wait_txd_empty2
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty2
  pla
  clc
  and #$0f
  tay
  lda hextable,y
  sta ACIA_DATA
.)
  ply
  pla
  rts


;;; read a line of input from the serial port
;;; leaves data in the buffer at INPUT
;;; y is the number of characters in the line, so it will fail if
;;; more then 255 characters are entered
;;; line terminated by carriage return. backspaces processed internally.
;;;
readline
  ldy #0
readchar
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA
  cmp #$08           ; check for backspace
  beq backspace
  cmp #$0D           ; check for newline
  beq done
  sta INPUT,y        ; track the input
  iny
  jsr puta           ; echo the typed character
  jmp readchar       ; loop to repeat
backspace
  cpy #0             ; beginning of line?
  beq readchar
  dey                ; if not, go back one character
  jsr puta           ; move cursor back
  jmp readchar

  ;; this is where we land if the line input has finished
  ;;
done
  rts



;;; print the string pointed to at PRINTVEC
;;;
printvecstr
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda (PRINTVEC),y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
.)
  rts


;;; print immediate -- hack the stack to find the string to print
;;; right after the JSR instruction, and when complete, jump over the
;;; string to resume execution.
;;;
DPL     =   $fd
DPH     =   $fe
primm:
      pla               ; get low part of (string address-1)
      sta   DPL
      pla               ; get high part of (string address-1)
      sta   DPH
      bra   primm3
primm2:
      jsr   puta        ; output a string char
primm3:
      inc   DPL         ; advance the string pointer
      bne   primm4
      inc   DPH
primm4:
      lda   (DPL)       ; get string char
      bne   primm2      ; output and continue if not NUL
      lda   DPH
      pha
      lda   DPL
      pha
      rts               ; proceed at code following the NUL



;;;
;;; Various string constants
;;;

hextable:	 .byte "0123456789ABCDEF"
prompt:		 .byte "-"
nocmderrstr:	 .byte "Command not recognized", $0d, $0a, $00
