;;;
;;; Test harness for SPI video using RA8875 board. This is basically
;;; the command line code from the monitor and the SPI code from FORTH
;;; moved to use the user VIA port and jammed together awkwardly.
;;;
;;; Pinout from the 6522 (PORTB) to the RA8875 board is as follows:
;;; D0  CLK
;;; D1  MOSI
;;; D2  CS
;;; D3  LIGHT
;;; D4  BUSY
;;; D5  RESET
;;; D6  NC
;;; D7  MISO
;;;


;;;
;;;
;;;
;;; definitions
;;;
;;;
;;;

* = $0300

SCRATCH    = $0010  ; through to $001F
ARGINDEX   = $0020  ; and on to $002F for up to 16 arguments
PRINTVEC   = $0042  ; and $0043. for printing routine.
ENTRY	   = $0044  ; and $0045
MEMTESTBASE= $0046  ; and $0047
INPUT      = $0200  ; block out this page for monitor command input

UVIA_PORTB = $8010
UVIA_PORTA = $8011
UVIA_DDRB  = $8012
UVIA_DDRA  = $8013

SPI_PORT   = UVIA_PORTB


;; colors
C_BLACK=$0000
C_BLUE=$001F 
C_RED=$F800  
C_GREEN=$07E0
C_CYAN=$07FF 
C_MAGENTA=$F81F
C_YELLOW=$FFE0 
C_WHITE=$FFFF  

;; Command/Data codes for SPI
DATAWRITE=$00
DATAREAD=$40 
CMDWRITE=$80 
CMDREAD =$C0  

;;;
;;; Include standard startup code
;;;

#include "../decl.a65"

;;; also include all the RA8875-specific definitions
#include "spivdefs.a65"

jmp start

#include "delay.a65"

;;;
;;; Dispatch table for CLI
;;;
;;; each entry has a two-byte pointer to the next entry (or $0000 on end)
;;; then a null-terminated string that names the command
;;; then a two-type pointer for the code to execute the command
;;;
table
  .word table1
  .byte "init", $00
  .word doinit
table1
  .word table2
  .byte "help", $00
  .word dohelp
table2
  .word table3
  .byte "text", $00
  .word dotext
table3
  .word table4
  .byte "echo", $00
  .word doecho
table4
  .word table5
  .byte "graph", $00
  .word dograph
table5
  .word table6
  .byte "squares", $00
  .word dosquares
table6
  .word table7
  .byte "quit", $00
  .word doquit
table7
  .word table8
  .byte "light", $00
  .word dolight
table8
  .word table9
  .byte "hello", $00
  .word dohello
table9
  .word table10
  .byte "cursor", $00
  .word docursor
table10
  .word table11
  .byte "rw", 0
  .word dorw
table11
  .word table12
  .byte "vinit", 0
  .word dovinit
table12
  .word table13
  .byte "white", 0
  .word dowhite
table13
  .word table14
  .byte "red", 0
  .word dored
table14
  .word table15
  .byte "blue", 0
  .word doblue
table15
  .word table16
  .byte "reg88", 0
  .word doreg88
table16
  .word table17
  .byte "reginit", 0
  .word doreginit
table17
  .word table18
  .byte "display", 0
  .word dodisplay
table18
  .word table19
  .byte "reg0", 0
  .word doreg0
table19
  .word $0000            ; signals last entry in the table
  .byte "colors", $00
  .word docolors



;;;
;;; SPI code
;;;
;;;


;;;
;;; Wiring details:
;;;   CLK is PB0, ie 1
;;;   MOSI is PB1, ie 2
;;;   CS is PB2, ie 4
;;;   MISO is PB7, which maps onto S flag on BIT (test with BPL and BMI)
;;; MISO, MOSI, and CS all have pull-up resisters, so they are high in
;;; the idle/unused state, except when pulled low by active circuitry.
;;;
;;; For the moment, this is the same setup as the SD card reader.
;;; Since I want to be able to set things up for keyboard input on
;;; on the same port, I'm likely to want to move some of the lines
;;; around later. However, for now, I wannt to use validated code.
;;;
;;; Other bits:
;;;    BACKLIGHT  PB3, ie 8
;;;    BUSY       PB4, ie 16
;;;    RESET      PB5, ie 32
;;;
;;; Device is SPI Mode 0. This means:
;;;   clock idles low
;;;   clock active high
;;;   data read on rising edge

SPI_CLK  = 1
SPI_MOSI = 2
SPI_CS   = 4
LIGHT    = 8
SPI_MISO = 128
BUSYMASK = 16
RESET    = 32

;;; set up data direction for SPI_PORT -- bits 0, 1, 2, 3, and 5 are
;;; outputs and bits 4, 6 (NC), and 7 are inputs.
setup6522
  lda #$2f
  sta UVIA_DDRB
  lda #SPI_MOSI|RESET|SPI_CS
  sta SPI_PORT
  rts


gettoken
  ; listen until we hear %11111110 (254/$FE)
  jsr recv8bits
  cmp #$FE
  bne gettoken
  rts


sendtoken
  lda #254
  jsr sendbyte
  rts


;; GET RID OF THIS
oldsendbyte
  phy
  ldy #8
sendloop
  asl
  pha
  bcc sendzero
sendone
  lda #SPI_MOSI
  tsb SPI_PORT
  bra send
sendzero
  lda #SPI_MOSI
  trb SPI_PORT
send
  inc SPI_PORT
  dec SPI_PORT
  pla
  dey
  bne sendloop
  ply
  rts


;;; Send a byte via SPI. This faster version of the original code
;;; unrolls the loop and relies on shifts rather than branches to
;;; determine the bit to send. This is written on the assumption
;;; that the CLK signal idles low.
;;;
sendbyte
  phy
  ;tay               ; y will store the data as we transmit it

; bit 7
  ;tya
  asl               ; moves bit to transmit into C (2 cycles)
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #2            ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles
  ;; NOTE used to have "dec SPI_PORT" right after the inc but I
  ;; moved it down to even out the duty cycle. I strongly suspect
  ;; that this is completely irrelevant. Once everything is working,
  ;; try moving it back since the code reads better in its original
  ;; configuration.

; bit 6
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 5
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 4
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 3
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 2
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 1
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

; bit 0
  tya               ; get remaining data from Y (2 cycles)
  asl               ; moves bit to transmit into C (2 cycles)
  dec SPI_PORT      ; 6 cycles
  tay               ; temporarily store in Y (2 cycles)
  
  ; two rotates will shift the carry into the MOSI position
  rol               ; move transmit bit to bit 0 (2 cycles)
  rol               ; move transmit bit to bit 1 (2 cycles)
  and #%00000010    ; clear out other bits (2 cycles)
  ora #RESET	    ; keep reset high!
  sta SPI_PORT      ; 4 cycles
  inc SPI_PORT      ; 6 cycles

  ;; set MOSI high at end
  lda #SPI_MOSI
  tsb SPI_PORT

  dec SPI_PORT      ; 6 cycles

  ply
  rts


getresponse
.(
  phx
  ldx #0
loop
  inx
  beq timedout
  jsr recv8bits
  cmp #$ff
  beq loop
timedout
  plx
  rts
.)

;;; read a byte via SPI from SPI_PORT, returned in accumulator.
;;; Assume the CLK idles low.
recv8bits
  phx               ; store X, since we'll use it (and can't use Y)
  lda #0            ; zero out initial result

  inc SPI_PORT      ; set CLK high for first bit
  ldx SPI_PORT      ; read data
  cpx #128          ; this sets carry flag to top bit
  rol               ; shift carry into A
  dec SPI_PORT      ; set clock off

  inc SPI_PORT      ; set CLK high #2
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #3
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #4
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #5
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #6
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #7
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #8
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  plx               ; restore X
  rts               ; return with data in A


;;; GET RID OF THIS
oldrecv8bits
  lda #0            ; zero out result
  inc SPI_PORT      ; set clock high
  lda SPI_PORT      ; read data
  cmp #128          ; this sets carry flag to top bit
  rol               ; shift carry into A
  dec SPI_PORT      ; set clock off
  ;; now fall through to receive next seven bits

;; this is a separate entry point used when we've already read or
;; tested one bit.
oldrecv7bits           ; used to be a loop, unrolled for speed
.(
  phx               ; store X, since we'll use it (and can't use Y)

  inc SPI_PORT      ; set CLK high #1
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #2
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #3
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #4
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #5
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #6
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  inc SPI_PORT      ; set CLK high #7
  ldx SPI_PORT      ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec SPI_PORT      ; set CLK low

  plx               ; restore X
.)
  rts               ; return with data in A


;;; poll the WAIT flag until it goes high
awaitfree
;  pha
;waitloop
;  lda SPI_PORT
;  and #BUSYMASK
;  beq waitloop
;  pla
  rts

wrcommand
  pha               ; cache value

  lda #SPI_CS       ; set CS to low
  trb SPI_PORT

  lda #CMDWRITE     ; send CMDWRITE
  jsr sendbyte
  pla               ; retreive value
  jsr sendbyte      ; send it

  lda #SPI_MOSI     ; set MOSI high
  tsb SPI_PORT

  lda #SPI_CS       ; set CS high
  tsb SPI_PORT
  rts

rdcommand
  lda #SPI_CS       ; set CS low
  trb SPI_PORT

  ;; send CMDREAD
  lda #CMDREAD      ; send CMDREAD
  jsr getresponse   ; receive data into A

  pha               ; cache it temporarily
  lda #SPI_CS       ; set CS high
  tsb SPI_PORT
  pla               ; retrieve data
  rts

wrdata
  pha
  ;; set CS low
  lda #SPI_CS
  trb SPI_PORT
  ;; send DATAWRITE
  lda #DATAWRITE
  jsr sendbyte
  pla
  ;; send A
  jsr sendbyte
  ;; set MOSI high
  lda #SPI_MOSI
  tsb SPI_PORT
  ;; set CS high
  lda #SPI_CS
  tsb SPI_PORT
  rts

rddata
  lda #SPI_CS       ; set CS low
  trb SPI_PORT

  lda #DATAREAD     ; send DATAREAD
  jsr sendbyte

  lda #SPI_MOSI     ; keep MOSI low while awaiting response
  trb SPI_PORT

  jsr recv8bits     ; get response into A
  pha               ; cache it for a moment

  lda #SPI_MOSI     ; set MOSI high
  tsb SPI_PORT
  lda #SPI_CS       ; set CS high
  tsb SPI_PORT

  pla               ; retreive data
  rts

;; write value in Y to register in A
writereg
  jsr wrcommand
  tya
  jsr wrdata
  rts
  


;;;
;;; RA8875 registers and controls
;;;

vidinit
  ;; initial setup -- CLOCK high, MOSI high, RESET high, CS high
  lda #SPI_CLK|SPI_MOSI|RESET|SPI_CS
  sta SPI_PORT

  ;; for reset -- hold RESET, CLK, and MOSI all low
  ;; that's basically everything except MISO, right?
  lda #SPI_MISO
  sta SPI_PORT
  ;; short pause
  jsr delay100ms
  ;; set RESET, CLK, MOSI and CS all high
  lda #RESET|SPI_CLK|SPI_MOSI|SPI_CS
  sta SPI_PORT
  jsr delay100ms

  ;; now set chip select low (and leave it there)
  ;lda #SPI_CS
  ;trb SPI_PORT
  ; the TRB wasn't working? RESET was going low again?
  lda #RESET|SPI_CLK|SPI_MOSI
  sta SPI_PORT


  lda #0
  jsr wrcommand
  jsr rddata
  cmp #$75
  bne fail
  lda #<successstr
  sta PRINTVEC
  lda #>successstr
  sta PRINTVEC+1
  jsr printvecstr
  bra endvidinit
fail
  jsr putax
  lda #<failstr
  sta PRINTVEC
  lda #>failstr
  sta PRINTVEC+1
  jsr printvecstr
endvidinit  
  rts

successstr .byte "reg 0 read successful", $0a, $0d, $0
failstr    .byte " != 0x75", $0a, $0d, $0

reginit
  lda #".
  jsr puta

  lda #PLLC1
  ldy #PLLC1_PLLDIV1+11
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  lda #PLLC2
  ldy #PLLC2_DIV4
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  lda #SYSR
  ldy #SYSR_16BPP|SYSR_MCU8
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #PCSR
  ldy #PCSR_PDATL|PCSR_2CLK
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #HDWR
  ldy #99
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #HNDFTR
  ldy #HNDFTR_DE_HIGH
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #HNDR
  ldy #24
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #HSTR
  ldy #3
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #HPWR
  ldy #HPWR_LOW+11
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;; vertical settings registers
  ;jsr awaitfree
  lda #VDHR0
  ldy #<479
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #VDHR1
  ldy #>479
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #VNDR0
  ldy #32
  jsr writereg
  jsr delay1ms


  lda #".
  jsr puta

  ;jsr awaitfree
  lda #VNDR1
  ldy #0
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #VSTR0
  ldy #32
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #VSTR1
  ldy #0
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #VPWR
  ldy #VPWR_LOW+1
  jsr writereg
  jsr delay1ms


  ;; active window X

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #HSAW0
  ldy #0
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #HSAW1
  ldy #0
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #HEAW0
  ldy #<799
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #HEAW1
  ldy #>799
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;; active window Y
  ;jsr awaitfree
  lda #VSAW0
  ldy #0
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #VSAW1
  ldy #0
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #VEAW0
  ldy #<799
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #VEAW1
  ldy #>799
  jsr writereg
  jsr delay1ms

  lda #".
  jsr puta

  ;jsr awaitfree
  lda #MCLR
  ldy #MCLR_START|MCLR_FULL
  jsr writereg

  jsr delay1s

  jsr crlf
  rts

doreg88
  lda #88
  jsr wrcommand
  jsr rddata
  jsr putax
  jsr crlf
  rts

doreg0
  lda #0
  jsr wrcommand
  jsr rddata
  jsr putax
  jsr crlf
  rts

displayon

  lda #"a
  jsr puta
  
  ;tft.displayOn(true);
  lda #PWRR
  ldy #PWRR_NORMAL|PWRR_DISPON
  jsr writereg
  
  lda #"b
  jsr puta
  
  ; tft.GPIOX(true);      // Enable TFT - display enable tied to GPIOX
  lda #GPIOX
  ldy #1
  jsr writereg

  lda #"c
  jsr puta
  
  ; tft.PWM1config(true, RA8875_PWM_CLK_DIV1024); // PWM output for backlight
  lda #P1CR
  ldy #P1CR_ENABLE|PWM_CLK_DIV1024
  jsr writereg
  
  lda #"d
  jsr puta
  
  ;tft.PWM1out(255);
  lda #P1DCR
  ldy #255
  jsr writereg

  lda #"e
  jsr puta

  jsr crlf
  
  rts


setcolors

  ;; set foreground to white
  jsr awaitfree
  lda #$63
  jsr wrcommand
  lda #31
  jsr wrdata
  lda #$64
  jsr wrcommand
  lda #0
  jsr wrdata
  lda #$65
  jsr wrcommand
  lda #0
  jsr wrdata

  ;; set background to black
  jsr awaitfree
  lda #$60
  jsr wrcommand
  lda #0
  jsr wrdata
  lda #$61
  jsr wrcommand
  lda #0
  jsr wrdata
  lda #$62
  jsr wrcommand
  lda #0
  jsr wrdata

  
  ;; Clear transparency flag
  lda #$22
  jsr wrcommand
  jsr rddata
  and #%10111111    ; clear bit 6
  jsr wrdata

  rts



;;;
;;;
;;; MAIN CODE ENTRY POINT
;;;
;;;

start

  ;; initialization?
  ;;

  phx               ; preserve x, since it's our private stack pointer
                    ; only valuable if we ever return of course

  jsr setup6522     ; set up the port

  lda #<greeting
  sta PRINTVEC
  lda #>greeting+1
  sta PRINTVEC+1
  jsr printvecstr


;;;
;;;
;;; COMMAND LINE INTERPRETER
;;;
;;;

reploop
.(
  ;; print the prompt
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda prompt
  sta ACIA_DATA
.)

  jsr readline      ; read a line into INPUT
  jsr crlf          ; echo line feed/carriage return

  ;; nothing entered? loop again
  cpy #0
  beq reploop

  ;; parse and process the command line
  ;;
  lda #0           
  sta INPUT,y       ; null-terminate the string
  jsr parseinput    ; parse into individual arguments, indexed at ARGINDEX
  jsr matchcommand  ; match input command and execute
  jmp reploop       ; loop around


parseinput
  ldx #0
  ldy #0

.(
;; look for non-space
nextchar
  lda INPUT,x
  cmp #32
  bne nonspace
  inx
  jmp nextchar

;; mark the start of the word
nonspace
  iny               ; maintain a count of words in y
  stx ARGINDEX,y
;; look for space
lookforspace
  inx
  lda INPUT,x
  beq endofline     ; check for null termination
  cmp #32           ; only looking for spaces. Tab?
  beq endofword
  jmp lookforspace
;; didn't hit a terminator, so there must be more.
;; terminate this word with a zero and then continue
endofword
  lda #0
  sta INPUT,x         ; null-terminate
  inx
  jmp nextchar        ; repeat
endofline
  ;; we're done
  ;; cache the arg count
  sty ARGINDEX

  rts
.)


;;;
;;; Command lookup and dispatch. Search the table for a string that
;;; matches the command entered. If it is found, jump to it. ENTRY
;;; points to the current entry in the table as we step through the
;;; list of commands.
;;;
;;; This is called as a subroutine. We jump to the code, so an rts
;;; from there will return to the interpeter loop; if we hit an error,
;;; we rts from here with the same effect.
;;;

matchcommand
  lda #<table    ; low byte of table address
  sta ENTRY
  lda #>table    ; high byte of table address
  sta ENTRY+1

testentry
cacheptr
  ;; grab the pointer to the next entry and cache it in scratchpad
  ldy #0
  lda (ENTRY),Y  ; first byte
  sta SCRATCH
  iny
  lda (ENTRY),Y  ; second byte
  sta SCRATCH+1
  iny
  ldx #0         ;; will use X and Yas index for string
.(
nextchar
  lda INPUT,x
  beq endofword
  cmp (ENTRY),y
  bne nextentry
  inx
  iny
  jmp nextchar
.)

endofword
  ;; we got here because we hit the end of the word in the buffer
  ;; if it's also the end of the entry label, then we've found the right place
  lda (ENTRY),y
  beq successful
  ;; but if it's not, then we haven't.
  ;; continue to the next entry
  jmp nextentry

successful
  ;; we got a match! copy out the destination address, jump to it
  iny
  lda (ENTRY),Y
  sta SCRATCH+2
  iny
  lda (ENTRY),Y
  sta SCRATCH+3
  jmp (SCRATCH+2)
  rts  ;; never get here -- we rts from the command code
    
nextentry
  lda SCRATCH           ;; copy the address of next entry from scratchpad
  sta ENTRY
  lda SCRATCH+1
  sta ENTRY+1
  ;; test for null here
  ora SCRATCH       ;; check if the entry was $0000
  beq endoftable    ;; if so, we're at the end of table
  jmp testentry

endoftable
  ;; got to the end of the table with no match
  ;; print an error message, and return to line input
  ;; ...

printerror
  lda #<nocmderrstr
  sta PRINTVEC
  lda #>nocmderrstr
  sta PRINTVEC+1
  jsr printvecstr
  rts



;;;
;;;
;;; COMMANDS CALLED FROM THE INTERPETER
;;;
;;;

dohelp
  lda #<helpstring
  sta PRINTVEC
  lda #>helpstring
  sta PRINTVEC+1
  jsr printvecstr
  rts

doecho
.(
  ldy #1                  ; start at 1 because we ignore the command itself
echonext
  cpy ARGINDEX            ; have we just done the last?
  beq end                 ; yes, so end
  iny                     ; no, so move on to the next
  ldx ARGINDEX,y
  ;; not using printvecstr for this because we're printing
  ;; directly out of the input buffer  
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda INPUT,x
  beq endofarg
  sta ACIA_DATA
  inx
  jmp next_char
endofarg
  lda #32                  ; put a space at the end
  jsr puta
  jmp echonext
end
  jsr crlf                 ; carriage return/line feed
  plx                      ; restore the stack pointer
  rts
.)


doquit
  pla               ; drop the most recent return address
  pla               ; so that we will return instead to the monitor
  plx               ; restore the FORTH stack pointer
  rts               ; exit


doinit
  jsr vidinit

  lda #<initstr1
  sta PRINTVEC
  lda #>initstr1
  sta PRINTVEC+1
  jsr printvecstr

  jsr reginit

  lda #<initstr2
  sta PRINTVEC
  lda #>initstr2
  sta PRINTVEC+1
  jsr printvecstr

  jsr displayon
  
  lda #<initstr3
  sta PRINTVEC
  lda #>initstr3
  sta PRINTVEC+1
  jsr printvecstr
rts

initstr1 .byte "RA8875 reset", $0a, $0d, $00
initstr2 .byte "registers set", $0a, $0d, $00
initstr3 .byte "display enabled", $0a, $0d, $00

dovinit
  jsr vidinit
  rts

doreginit
  jsr reginit
  rts

dodisplay
  jsr displayon
  rts

DLSTART=$80
DLSTOP=$00
DRAWSQUARE=$10
FILL=$20

setwhite
  lda #$63
  jsr wrcommand

  ;writeData((color & 0xf800) >> 11)
  lda #$1f
  jsr wrdata

  lda #$64
  jsr wrcommand

  ;writeData((color & 0x07e0) >> 5)
  lda #$3f
  jsr wrdata

  lda #$65
  jsr wrcommand
  ;writeData((color & 0x001f))
  lda #$1f
  jsr wrdata
  rts
  

setred
  lda #$63
  jsr wrcommand

  ;writeData((color & 0xf800) >> 11)
  lda #$1f
  jsr wrdata

  lda #$64
  jsr wrcommand

  ;writeData((color & 0x07e0) >> 5)
  lda #0
  jsr wrdata

  lda #$65
  jsr wrcommand
  ;writeData((color & 0x001f))
  lda #0
  jsr wrdata
  rts
  

setblue
  lda #$63
  jsr wrcommand

  ;writeData((color & 0xf800) >> 11)
  lda #0
  jsr wrdata

  lda #$64
  jsr wrcommand

  ;writeData((color & 0x07e0) >> 5)
  lda #0
  jsr wrdata

  lda #$65
  jsr wrcommand
  ;writeData((color & 0x001f))
  lda #$1f
  jsr wrdata
  rts
  


fillscreen
  lda #DCR
  jsr wrcommand
  
  lda #DLSTOP|DRAWSQUARE
  jsr wrdata
  lda #DLSTART|FILL|DRAWSQUARE
  jsr wrdata
  rts


dowhite
  jsr setwhite
  jsr fillscreen
  rts
  
doblue
  jsr setblue
  jsr fillscreen
  rts
  
dored
  jsr setred
  jsr fillscreen
  rts

dotext
  lda #"1
  jsr puta

  ;; wait until free
  jsr awaitfree

  lda #"2
  jsr puta

  ;; send command 0x40 (MWCR0 register)
  lda #$40
  jsr wrcommand

  lda #"3
  jsr puta

  ;; read response
  jsr rddata
  ;; set bit 7
  ora #$80
  ;; write it back as data
  jsr wrdata

  lda #"4
  jsr puta

  ;; font selection
  lda #$21
  jsr wrcommand
  jsr rddata
  and #%0101111     ; clear bits 7 and 5
  jsr wrdata

  lda #"5
  jsr puta

  jsr setcolors

  lda #<textstr
  sta PRINTVEC
  lda #>textstr
  sta PRINTVEC+1
  jsr printvecstr
  rts

textstr .byte "text mode set", 10, 13, $00

dorw
  lda #".
  jsr puta
  lda #MWCR0
  jsr wrcommand
  lda #".
  jsr puta
  jsr rddata
  jsr putax
  jsr crlf
  rts

docursor
  lda #MWCR0
  jsr wrcommand
  jsr rddata
  ora MWCR0_CURSOR
  jsr wrdata

  lda #MWCR0
  jsr wrcommand
  jsr rddata
  ora MWCR0_BLINK
  jsr wrdata

  lda #BTCR
  jsr wrcommand
  lda #128
  jsr wrdata

  lda #<curstr
  sta PRINTVEC
  lda #>curstr
  sta PRINTVEC+1
  jsr printvecstr
  rts

curstr .byte "cursor on", 10, 13, 0


dograph
  rts

dohello
.(
  lda #MRWC
  jsr wrcommand
  ldy #0
strloop
  lda hellostr,y
  beq endstr
  jsr wrdata
  iny
  bra strloop
endstr
  lda #<hdonestr
  sta PRINTVEC
  lda #>hdonestr
  sta PRINTVEC+1
  jsr printvecstr
  rts
.)

hellostr .byte "Hello hello hello hello hello", $00
hdonestr .byte "written", 10, 13, $0

dosquares
  rts

docolors
  rts

light .byte 0

dolight
  lda light
  bne lightoff
  inc light
  lda #LIGHT
  tsb SPI_PORT
  rts
lightoff
  dec light
  lda #LIGHT
  trb SPI_PORT
  rts





;;;;;;;;;;;;;
;;;
;;; Various utility routines
;;;
;;;;;;;;;;;;;

;;;
;;; Ouptut carriage return and line feed
;;;
crlf
  pha
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0d
  sta ACIA_DATA
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0a
  sta ACIA_DATA
  pla
  rts


;;;
;;; output the character code in the accumulator
;;;
puta
.(
  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts

;;;
;;; output the value in the accumulator as a hex pattern
;;; NB x cannot be guaranteed to be stack ptr during this... check...
;;;
putax
.(
  phy

  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  pha             ; put a copy back
  clc
  and #$f0
  ror
  ror
  ror
  ror
  tay
  lda hextable,y
  sta ACIA_DATA
wait_txd_empty2
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty2
  pla
  clc
  and #$0f
  tay
  lda hextable,y
  sta ACIA_DATA
.)
  ply
  rts


;;; read a line of input from the serial interface
;;; leaves data in the buffer at INPUT
;;; y is the number of characters in the line, so it will fail if
;;; more then 255 characters are entered
;;; line terminated by carriage return. backspaces processed internally.
;;;
readline
  ldy #0
readchar
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA
  cmp #$08           ; check for backspace
  beq backspace
  cmp #$0D           ; check for newline
  beq done
  sta INPUT,y        ; track the input
  iny
  jsr puta           ; echo the typed character
  jmp readchar       ; loop to repeat
backspace
  cpy #0             ; beginning of line?
  beq readchar
  dey                ; if not, go back one character
  jsr puta           ; move cursor back
  jmp readchar

  ;; this is where we land if the line input has finished
  ;;
done
  rts




;;; print the string pointed to at PRINTVEC
;;;
printvecstr
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda (PRINTVEC),y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
.)
  rts




;;;
;;; Various string constants
;;;

hextable:	 .byte "0123456789ABCDEF"
greeting:	 .byte "SPI Video test", $0d, $0a, $00
prompt:		 .byte "-"
helpstring:	 .byte "Commands available: help, init, text, rw, graph, echo, squares, light, cursor, colors, hello, quit", $0d, $0a, $00
nocmderrstr:	 .byte "Command not recognized", $0d, $0a, $00
