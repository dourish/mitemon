;;;
;;; Standalone text editor. It's based on the editor in SECND but with
;;; a very different data structure and an expectation of a 80x24 screen.
;;;
;;; Paul Dourish, July 2019
;;;

* = $0300

  jmp start

;;; these variables are imported from the monitor/FORTH
PRINTVEC=$0042
INPUT=$7F00
SCRATCH=$0010
CURSEC=$0068
WORD=$7EC0
LBLOCK=$7C00
HBLOCK=$7D00

;;; Data structures/Rationale
;;;
;;; Text data is held in a doubly-linked list of lines. Each is 84 bytes
;;; long; two bytes of forward pointer, two bytes of backwards pointer,
;;; and 80 bytes of character data. I use the term "lines" to refer to
;;; these data structures, and "row" and "column" to refer to screen
;;; space. The line data structures are allocatd in an area from DATASTART
;;; to DATAEND. NEXTFREE points to the next available space. FIRSTLINE
;;; and LASTLINE indicate the first and last lines of the text file.
;;;
DATASTART=$4000     ; base of data storage area
DATAEND=$7C00       ; end of data storage

;;; the $0070 area is used by FORTH but not for anything that might run
;;; while the editor is running, so is safe to reuse.
NEXTFREE=$0070 ; and 0071 -- address of next free line structure
LASTLINE=$0072 ; and 0073 -- address of final line structure
CURLINE=$0074  ; and 0075 
CURDATA=$0076  ; and 0077
BUFPTR=$0078   ; and 0079
DATAPTR=$007A  ; and 007B
row=$007C
col=$007D
lower=$007E    ; and 007F

temp=SCRATCH+15

CLUSTER     .word 0
FILELEN     .word 0
            .word 0
SECTOR      .word 0
            .word 0
MAXBUF      .byte 0
MAXDATA     .byte 0
SCREENSTART .word 0

NROWS=24
MAXROW=NROWS-3
SENTINELROW=MAXROW+2
NCOLS=80
MAXCOL=NCOLS-1


#include "../decl.a65"
#include "../stack.a65"
#include "jmptable.a65"

table
  .word tostart     ; a
  .word back        ; b
  .word undefined   ; c
  .word delfwd      ; d
  .word toend       ; e
  .word forw        ; f
  .word undefined   ; g
  .word delback     ; h
  .word undefined   ; i
  .word undefined   ; j
  .word delline     ; k
  .word repaint     ; l
  .word newline     ; m
  .word nextrow     ; n
  .word openline    ; o
  .word prevrow     ; p
  .word undefined   ; q
  .word undefined   ; r
  .word undefined   ; s
  .word testcode    ; t
  .word undefined   ; u
  .word nextpage    ; v
  .word undefined   ; w
  .word exit        ; x
  .word undefined   ; y
  .word undefined   ; z


start

  ;;;
  ;;; *** FILE READING/PARSING
  ;;; Loads file data before editor begins
  ;;;

  ;; First, extract filename the command line, and copy it into
  ;; WORD as a counted string
  jsr p1toword
  bcc checkfile
  rts

checkfile
  ;; look up the filename in the dictionary.
  clc
  jsr ROMFINDDIRW
  bcc fileready     ; when file already exists

newfile
  ;; the named file does not exist, so make a new file with that name
  ;; .. which means to put filename as c-string on the stack
  ;; .. then jsr newfilesub
  dex
  dex
  lda #<WORD
  sta stackbase+1,x
  lda #>WORD
  sta stackbase+2,x
  jsr ROMNEWFILE

  lda #<createmsg
  sta PRINTVEC
  lda #>createmsg
  sta PRINTVEC+1
  jsr ROMPRTSTR

fileready
  ;; at this point, the file is set up. the directory sector is in
  ;; the LBLOCK/HBLOCK area, and the stack has the double-precision
  ;; sector number and a pointer to the directory entry within it
  ;; so the cluster number is at ptr + 26,27

  ;; get cluster number and cache it
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1
  ldy #26
  lda (SCRATCH),y
  sta CLUSTER
  iny
  lda (SCRATCH),y
  sta CLUSTER+1

  ;; get file length and cache it
  iny
  lda (SCRATCH),y
  sta FILELEN
  iny
  lda (SCRATCH),y
  sta FILELEN+1
  iny
  lda (SCRATCH),y
  sta FILELEN+2
  iny
  lda (SCRATCH),y
  sta FILELEN+3

  ;; put cluser number onto the stack as a double
  inx
  inx
  lda CLUSTER
  sta stackbase+1,x
  lda CLUSTER+1
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  jsr cltosector    ; turn cluster number into sector number on stack

  ;; cache the sector number
  lda stackbase+1,x
  sta SECTOR
  lda stackbase+2,x
  sta SECTOR+1
  lda stackbase+3,x
  sta SECTOR+2
  lda stackbase+4,x
  sta SECTOR+3

  ;; set up variables
  lda #<DATASTART
  sta NEXTFREE
  sta LASTLINE
  lda #>DATASTART
  sta NEXTFREE+1
  sta LASTLINE+1
  lda #<LBLOCK
  sta BUFPTR
  lda #>LBLOCK
  sta BUFPTR+1

  ;; I'm going to start messing with LBLOCK, so clear out the
  ;; sector cache so as not to confuse myself later.
  stz CURSEC
  stz CURSEC+1
  stz CURSEC+2
  stz CURSEC+3


loadsector
  ;; load sector data into LBLOCK area
  dex
  dex
  lda #<LBLOCK
  sta stackbase+1,x
  lda #>LBLOCK
  sta stackbase+2,x

  jsr ROMLOADMEM

;  lda #"1
;  jsr ROMPUTA  

loadline
  ;; open a new line structure and start to load data into it  

  ;; allocate a new line data structure. At the start, LASTLINE is
  ;; is the current final line (or zero if there is no last line),
  ;; and NEXTFREE is the line we are allocating.
  ;;
  ldy #2            ; set backward pointer from new line to last
  lda LASTLINE
  sta (NEXTFREE),y
  iny
  lda LASTLINE+1
  sta (NEXTFREE),y

  ldy #1            ; set forward pointer from last line to new
  lda NEXTFREE
  sta (LASTLINE)
  lda NEXTFREE+1
  sta (LASTLINE),y

  ldy #1            ; zero out forward pointer for new line
  lda #0
  sta (NEXTFREE)
  sta (NEXTFREE),y

  lda NEXTFREE      ; reset LASTLINE pointer
  sta LASTLINE
  lda NEXTFREE+1
  sta LASTLINE+1

  clc               ; update pointer to next free structure
  lda NEXTFREE
  adc #84           ; constant is size of structure
  sta NEXTFREE
  lda NEXTFREE+1
  adc #0
  sta NEXTFREE+1

  ;; set up CURLINE and CURDATA
  clc
  lda LASTLINE
  sta CURLINE
  adc #4
  sta CURDATA
  lda LASTLINE+1
  sta CURLINE+1
  adc #0
  sta CURDATA+1

  lda CURDATA
  sta DATAPTR
  lda CURDATA+1
  sta DATAPTR+1

continueline
  ;; copy data into new line
copyline
  ;; set up MAXDATA to signal end of data
  stz MAXDATA       ; default, ie no maximum (will be capped at 80)
  lda FILELEN+1     ; are we down to the last page yet?
  bne nomax         ; no, so continue
  lda FILELEN
  sta MAXDATA       ; yes, so set maximum to remaining data
nomax

  ;; set up BUFLIMIT to signal end of buffer
  stz MAXBUF        ; 0 is default (no limit)
  lda BUFPTR+1
  cmp #>HBLOCK      ; are we in the upper half of the buffer?
  bne nolimit       ; no, so no problem
  sec
  lda MAXBUF        ; calculate maximum remaining characters
  sbc BUFPTR        ; BUG CHECK FOR OFF-BY-1 ERROR!
  sta MAXBUF
nolimit

  ldy #0
copydata
;  lda #"2
;  jsr ROMPUTA

  lda (BUFPTR),y
;  jsr ROMPUTA
  sta (DATAPTR),y
  iny
  cmp #$0A          ; $A = LF = end-of-line marker
  beq endofline
  cpy #80           ; BUG this presumes we are not filling an open line
  beq endofline     ; but for the moment as long as I am dealing with
  cpy MAXBUF        ; regular text files it should be okay
  beq endofbuffer
  cpy MAXDATA
  bne copydata
  jmp endofdata

endofline  
;  lda #"3
;  jsr ROMPUTA
;  jsr crlf

  ;; update BUFPTR
  clc
  tya
  adc BUFPTR
  sta BUFPTR
  lda BUFPTR+1
  adc #0
  sta BUFPTR+1

  ;; update FILELEN
  tya
  sta SCRATCH
  sec
  lda FILELEN
  sbc SCRATCH
  sta FILELEN
  lda FILELEN+1
  sbc #0
  sta FILELEN+1
  lda FILELEN+2
  sbc #0
  sta FILELEN+2
  lda FILELEN+3
  sbc #0
  sta FILELEN+3

  lda FILELEN+1
;  jsr putax
  lda FILELEN
;  jsr putax
;  jsr crlf

  lda FILELEN
  ora FILELEN+1
.(
  bne continue
  jmp  endofdata
continue
.)

  jmp loadline

endofbuffer
;  lda #"5
;  jsr ROMPUTA

  sty SCRATCH       ; cache Y in SCRATCH, we need it a couple of times

  ;; no more data? (do this test both before and after)
  lda FILELEN
  ora FILELEN+1
  beq endofdata

  ;; update FILELEN
  sec
  lda FILELEN
  sbc SCRATCH
  sta FILELEN
  lda FILELEN+1
  sbc #0
  sta FILELEN+1
  lda FILELEN+2
  sbc #0
  sta FILELEN+2
  lda FILELEN+3
  sbc #0
  sta FILELEN+3

  ;; no more data?
  lda FILELEN
  ora FILELEN+1
  beq endofdata

  lda FILELEN+3
  bne endofdata     ; in case we've gone negative

  ;; update DATAPTR with data loaded so far
  clc
  lda DATAPTR
  adc SCRATCH
  sta DATAPTR
  lda DATAPTR+1
  adc #0
  sta DATAPTR+1

  ;; set up the stack to load a new buffer
  dex
  dex
  dex
  dex
  clc
  lda SECTOR
  adc #1
  sta stackbase+1,x
  sta SECTOR
  lda SECTOR+1
  adc #0
  sta SECTOR+1
  sta stackbase+2,x
  lda SECTOR+2
  adc #0
  sta SECTOR+2
  sta stackbase+3,x
  lda SECTOR+3
  adc #0
  sta SECTOR+3
  sta stackbase+4,x

  dex
  dex
  lda #<LBLOCK
  sta stackbase+1,x
  sta BUFPTR        ; reset BUFPTR while we're at it
  lda #>LBLOCK
  sta stackbase+2,x
  sta BUFPTR+1

  jsr ROMLOADMEM
  jmp copyline

endofdata
;  lda #"6
;  jsr ROMPUTA

finish
  ;; for debugging, print what we've read

#if 0
  jsr crlf

  lda #<DATASTART
  sta CURLINE
  lda #>DATASTART
  sta CURLINE+1

printline
;  lda CURLINE+1
;  jsr putax
;  lda CURLINE
;  jsr putax
;  jsr ROMGET
;  cmp #"q
;  beq doneprint
;  jsr crlf

  ldy #4
printloop
  lda (CURLINE),y
  jsr ROMPUTA
  cmp #$0A
  beq finishline
  iny
  cpy #80
  beq doneline
  bra printloop

finishline
  lda #$0D
  jsr ROMPUTA
doneline
  ldy #1
  lda (CURLINE)
  sta SCRATCH
  lda (CURLINE),y
  sta SCRATCH+1

  lda SCRATCH
  ora SCRATCH+1
  beq doneprint

  lda SCRATCH
  sta CURLINE
  lda SCRATCH+1
  sta CURLINE+1

  bra printline  

doneprint
#endif

  ;; file loading is complete. start the editor.
  jmp editstart



;;;
;;; *** EDIT CONTROL
;;;

editstart
  jsr cls
  jsr home
  stz row
  stz col
  lda #<DATASTART
  sta CURLINE
  sta SCREENSTART
  lda #>DATASTART
  sta CURLINE+1
  sta SCREENSTART+1
  clc
  lda CURLINE
  adc #4
  sta CURDATA
  lda CURLINE+1
  adc #0
  sta CURDATA+1

  jmp repaint       ; which will then jump into editloop below

;;; This is the main editor dispatch loop. Fetch a character; if it's
;;; in the command-code range, then look it up in the table; otherwise,
;;; insert it. Everything is done with JMPs and every command JMPs back
;;; to here. Escape is handled with a separate messy routine that should
;;; really be a second table.
editloop

  jsr ROMGET
  cmp #$1B        ; if it's less than 27, it's a control code
  beq escape      ; exactly 27 is escape
  bcs notcmd      ; over 27 is not a command
  dec             ; subtract 1 (to turn it into a 0-ranged value)
  asl             ; shift to multiply by two
  tax             ; that's an offset, so put it in X
;  lda table,x     ; look up the table value at X
;  sta jmpvec      ; and store it in jmpvec
;  lda table+1,x
;  sta jmpvec+1
;  jmp (jmpvec)    ; jump to the address
  jmp (table,x)

  bra editloop    ; shouldn't need this but included for safety

notcmd
  jsr insert
  bra editloop

escape
  jsr ROMGETCH
  cmp #"f"
  beq escf
  cmp #"b"
  beq escb
  cmp #"v"
  beq escv
  cmp #"<
  beq escless
  cmp #">
  beq escgreater
  cmp #"["
  beq arrow
  jmp editloop
escf
  jmp fowdword
escb
  jmp backword
escv
  jmp prevpage
escless
  jmp filestart
escgreater
  jmp fileend
arrow
  jsr ROMGETCH
  cmp #"A"
  beq arrowup
  cmp #"B"
  beq arrowdown
  cmp #"C"
  beq arrowright
  cmp #"D"
  beq arrowleft
  jmp editloop
arrowup
  jmp prevrow
arrowdown
  jmp nextrow
arrowright
  jmp forw
arrowleft
  jmp back

;; output the text for one line object, pointed to by lower. 
;; do the output directly (faster without subroutine call).
paintrow
.(
  phy
  ldy #4
rdyloop
  lda ACIA_STATUS
  and #$10
  beq rdyloop
  lda (lower),y
  beq done
  cmp #$0A
  beq done
  sta ACIA_DATA
  iny
  cpy #MAXCOL
  beq done
  bra rdyloop
done
  ply
  rts
.)

;;; clear below and print from current row to the bottom of
;;; of the screen. (uses rowbase to point to line)
paintdown
.(
  lda CURLINE
  sta lower
  lda CURLINE+1
  sta lower+1
  lda row
  pha               ; stash the row count
  lda col
  pha               ; stash the column count
  stz col
paintloop
  jsr moveto
  jsr clrtoend
  jsr paintrow
  lda row
  inc
  cmp #SENTINELROW
  beq endpaint
  sta row
  clc

  ldy #1            ; move to next line in data
  lda (lower)
  pha
  lda (lower),y
  sta lower+1
  pla
  sta lower

  ora lower+1
  beq endpaint      ; end of data

  bra paintloop
endpaint
  pla
  sta col
  pla
  sta row
  jsr moveto
  rts
.)

;;; repaint the whole screen, saving and then restoring cursor position
;;;
repaint
  lda row
  pha
  lda col
  pha
  lda CURLINE
  pha
  lda CURLINE+1
  pha
  stz row
  stz col
  lda SCREENSTART
  sta CURLINE
  lda SCREENSTART+1
  sta CURLINE+1
  jsr cls
  jsr home
  jsr paintdown
  pla
  sta CURLINE+1
  pla
  sta CURLINE
  pla
  sta col
  pla
  sta row
  jsr addstatus
  jsr moveto
  jmp editloop


addstatus
  lda #$1B ; ESC
  jsr ROMPUTCH
  lda #$5B ; [
  jsr ROMPUTCH
  lda #23
  jsr todecimal
  lda #$3B  ; semic
  jsr ROMPUTCH
  lda #1
  jsr todecimal
  lda #$48  ; H
  jsr ROMPUTCH
  lda #$2b  ; +
  jsr ROMPUTCH
  ldy #78
statusloop
  lda #"-
  jsr ROMPUTCH
  dey
  bne statusloop
  lda #$2b  ; +
  jsr ROMPUTCH
  rts


;;;
;;; *** EDITOR COMMANDS
;;;

insert
  jmp editloop

tostart
  stz col
  jsr moveto
  jmp editloop

back
.(
  lda col
  beq donothing
  dec col
  jsr moveto
donothing
 jmp editloop
.)

undefined
  jmp editloop

delfwd
  jmp editloop

toend
.(
  ldy #$00
endloop
  lda (CURDATA),y
  beq atend         ; we read a newline if there's a null -- BUG?
  cmp #$0A          ; newline signals end of line
  beq atend
  iny
  cpy #MAXCOL
  beq atend
  bra endloop
atend
  sty col
  jsr moveto
  jmp editloop
.)

forw
.(
  lda col
  cmp #MAXCOL ; #$3F
  beq donothing     ; do nothing at the maximum column
  ldy col
  lda (CURDATA),y
  beq donothing     ; read null as end-of-line -- BUG?
  cmp #$0A
  beq donothing     ; do nothing at end-of-line
  inc col
  jsr moveto
donothing
 jmp editloop
.)


delback
  jmp editloop

delline
  jmp editloop

newline
  jmp editloop

nextrow
.(
  lda CURLINE       ; do nothing if there is no more data
  ora CURLINE+1
  beq donothing

  lda row
  cmp #MAXROW       ; do nothing if we're on the last row
  beq scrollfwd     ; BUG fix this once I want to scroll around

  inc row
  ldy #1
  lda (CURLINE)
  pha
  lda (CURLINE),y
  sta CURLINE+1
  pla
  sta CURLINE
  jsr moveto

  clc
  lda CURLINE
  adc #4
  sta CURDATA
  lda CURLINE+1
  adc #0
  sta CURDATA+1

donothing
 jmp editloop

scrollfwd

  phx
  ldx #12
  lda SCREENSTART
  sta SCRATCH
  lda SCREENSTART+1
  sta SCRATCH+1

lineloop
  ldy #1
  lda (SCRATCH),y
  pha
  lda (SCRATCH)
  sta SCRATCH
  pla
  sta SCRATCH+1
  dex
  bne lineloop
  plx

  lda SCRATCH
  sta SCREENSTART
  lda SCRATCH+1
  sta SCREENSTART+1

  ldy #1
  lda (CURLINE)
  pha
  lda (CURLINE),y
  sta CURLINE+1
  pla
  sta CURLINE
  jsr moveto

  clc
  lda CURLINE
  adc #4
  sta CURDATA
  lda CURLINE+1
  adc #0
  sta CURDATA+1

  lda #10
  sta row

  jmp repaint
.)

openline
  jmp editloop

prevrow
.(
  ldy #2            ; do nothing if at first line of data
  lda #<CURLINE     ; as signaled by line that points to itself in
  cmp (CURLINE),y   ; its back-pointer
  bne nextcheck
  lda (CURLINE),y
  cmp #>CURLINE
  beq donothing  

nextcheck
  lda row           ; top line of screen but prior data, so scroll back
  beq scrollback

  ldy #3            ; follow back-pointer from current line to get
  lda (CURLINE),y   ; last one, and update both CURLINE and CURDATA
  pha
  dey
  lda (CURLINE),y
  sta CURLINE
  pla
  sta CURLINE+1

  clc
  lda CURLINE
  adc #4
  sta CURDATA
  lda CURLINE+1
  adc #0
  sta CURDATA+1

  dec row
  jsr moveto

donothing
  jmp editloop

scrollback
  ;; find a new SCREENSTART. start with the current one and go back
  ;; up to 15 lines (or until the start of the data).

  lda SCREENSTART
  sta SCRATCH
  lda SCREENSTART+1
  sta SCRATCH+1

  phx
  ldx #15
lineloop
  ;; It would be safe not to look for an end of the pointer chain, because
  ;; the first line's back pointer always points to itself. But we need
  ;; to know how many lines back we have scrolled so that we can position
  ;; the cursor correctly.

  ldy #2
  lda (SCRATCH),y
  cmp SCRATCH
  bne continue
  iny
  lda (SCRATCH),y
  cmp SCRATCH+1
  beq endloop

continue
  ldy #3            ; follow the back-pointer
  lda (SCRATCH),y
  pha
  dey
  lda (SCRATCH),y
  sta SCRATCH
  pla
  sta SCRATCH+1

  dex
  bne lineloop
endloop
  stx temp
  plx

  lda SCRATCH
  sta SCREENSTART
  lda SCRATCH+1
  sta SCREENSTART+1

  ;; curline should move one back
  ldy #2
  lda (CURLINE),y
  pha
  iny
  lda (CURLINE),y
  sta CURLINE+1
  pla
  sta CURLINE

  clc
  lda CURLINE
  adc #4
  sta CURDATA
  lda CURLINE+1
  adc #0
  sta CURDATA+1

  sec
  lda #14      ; 15 was our count; 14 is one less because we are moving
  sbc temp     ; up one line.
  sta row
  jsr moveto

  jmp repaint
.)

testcode
  jmp editloop

exit
  lda #NROWS
  dec
  sta row
  stz col
  jsr moveto
  rts

fowdword
  jmp editloop

backword
  jmp editloop

nextpage
.(
  ;; reset SCREENSTART forward by about 20 lines
  phx

  ldx #NROWS
  dex
  dex
  dex

  lda SCREENSTART
  sta SCRATCH
  lda SCREENSTART+1
  sta SCRATCH+1

lineloop
  ;; is there another line? look at forward pointer
  ldy #0
  lda (SCRATCH),y
  iny
  ora (SCRATCH),y
  beq endloop

  lda (SCRATCH),y
  pha
  dey
  lda (SCRATCH),y
  sta SCRATCH
  pla
  sta SCRATCH+1

  txa
  jsr putax
  dex
  bne lineloop
endloop
  plx

  lda SCRATCH
  sta SCREENSTART
  lda SCRATCH+1
  sta SCREENSTART+1
  stz row
  stz col

  lda SCREENSTART
  sta CURLINE
  lda SCREENSTART+1
  sta CURLINE+1
  clc
  lda CURLINE
  adc #4
  sta CURDATA
  lda CURLINE+1
  adc #0
  sta CURDATA+1

  jmp repaint
.)

prevpage
  jmp editloop

filestart
  lda #<DATASTART
  sta SCREENSTART
  lda #>DATASTART
  sta SCREENSTART+1

  stz row
  stz col
  lda SCREENSTART
  sta CURLINE
  lda SCREENSTART+1
  sta CURLINE+1
  clc
  lda CURLINE
  adc #4
  sta CURDATA
  lda CURLINE+1
  adc #0
  sta CURDATA+1
  jmp repaint

fileend
.(
  ;; jump to a point about 10 lines from the end of the file

  phx
  ldx #12

  lda LASTLINE
  sta SCRATCH
  lda LASTLINE+1
  sta SCRATCH+1

lineloop
  ldy #2
  lda (SCRATCH),y
  pha
  iny
  lda (SCRATCH),y
  sta SCRATCH+1
  pla
  sta SCRATCH

  dex
  bne lineloop

  ;; reuse code from above???

  lda SCRATCH
  sta SCREENSTART
  lda SCRATCH+1
  sta SCREENSTART+1

  stz row
  stz col
  lda SCREENSTART
  sta CURLINE
  lda SCREENSTART+1
  sta CURLINE+1
  clc
  lda CURLINE
  adc #4
  sta CURDATA
  lda CURLINE+1
  adc #0
  sta CURDATA+1
  jmp repaint
.)



;;;
;;; *** SCREEN CONTROL
;;;

;; for small integers (<100), convert to decimal and output
todecimal
.(
  ldy #$30
  sty temp  ; temp
convloop
  cmp #$0A
  bmi donedigit
  sec
  sbc #$0A
  inc temp
  bne convloop
donedigit
  tay
  lda temp
  jsr ROMPUTCH
  tya
  clc
  adc #$30
  jsr ROMPUTCH
  rts
.)

cls
  lda #$1B  ; esc
  jsr ROMPUTCH
  lda #$5B  ; "["
  jsr ROMPUTCH
  lda #$32  ; "2"
  jsr ROMPUTCH
  lda #$4A  ; "J"
  jsr ROMPUTCH
  rts

home
  lda #$1B  ; esc
  jsr ROMPUTCH
  lda #$5B  ; [
  jsr ROMPUTCH
  lda #$48  ; H
  jsr ROMPUTCH
  rts

clrtoend
  lda #$1B  ; ESC
  jsr ROMPUTCH
  lda #$5B  ; [
  jsr ROMPUTCH
  lda #$30  ; 0
  jsr ROMPUTCH
  lda #$4A ; H
  jsr ROMPUTCH
  rts

moveto
  lda #$1B ; ESC
  jsr ROMPUTCH
  lda #$5B ; [
  jsr ROMPUTCH
  lda row  ; row
  inc               ; code counts from 0, terminal counts from 1
  jsr todecimal
  lda #$3B  ; semic
  jsr ROMPUTCH
  lda col  ; col
  inc               ; code counts from 0, terminal counts from 1
  jsr todecimal
  lda #$48  ; H
  jsr ROMPUTCH
  rts





;;;
;;; *** LIBRARY ROUTINES
;;;

;;; extract first parameter and store it in WORD
;;;
p1toword
.(
  ldy #0
  ;; skip to first space (ie skip past the command)
skip1
  lda INPUT,y
  beq p1error
  cmp #32
  beq skip2
  iny
  beq p1error
  bra skip1
  ;; now skip to first following non-space (ie start of filename)
skip2
  lda INPUT,y
  beq p1error
  cmp #32
  bne copychars
  iny
  beq p1error
  bra skip2
copychars
  phx
  ldx #1
nextchar
  lda INPUT,y
  sta WORD,x
  beq donecopy
  cmp #32
  beq donecopy
  inx
  iny
  bne nextchar
donecopy
  stx WORD          ; store the character count
  plx
  clc
  bra p1end

p1error
  ;; there's been some problem finding the name, so
  ;; report an error and quit.
  lda #<p1errstr
  sta PRINTVEC
  lda #>p1errstr
  sta PRINTVEC+1
  jsr ROMPRTSTR
  sec
.)
p1end
  rts


;; convert a cluster address into a sector address
;; calculation is cluster-2 * sectors/cluster + resv + len FATs + len root
;; generally, cluster-2 * 64 + 545
cltosector
.(
  ;; subtract 2
  sec
  lda stackbase+1,x
  sbc #2
  sta stackbase+1,x
  lda stackbase+2,x
  sbc #0
  sta stackbase+2,x
  lda stackbase+3,x
  sbc #0
  sta stackbase+3,x
  lda stackbase+4,x
  sbc #0
  sta stackbase+4,x
done
.)

  ;; shift left 6 times, to multiply by 64
  clc
  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  rol stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  ;; add 545 ( = 512+33 = 2*256 + 33)
  clc
  lda stackbase+1,x
  adc #33
  sta stackbase+1,x
  lda stackbase+2,x
  adc #2
  sta stackbase+2,x
  lda stackbase+3,x
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  adc #0
  sta stackbase+4,x

  rts


p1errstr .byte "Usage: med filename", $0a, $0d, $00
fileerrstr .byte "Error: file already exists", $0a, $0d, $00
replacestr .byte "Replace existing file? ", $00
createmsg  .byte "Creating new file", $0a, $0d, $00


putax
.(
  phy

  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  pha             ; put a copy back
  clc
  and #$f0
  ror
  ror
  ror
  ror
  tay
  lda hextable,y
  sta ACIA_DATA
wait_txd_empty2
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty2
  pla
  clc
  and #$0f
  tay
  lda hextable,y
  sta ACIA_DATA
.)
  ply
  rts

crlf
  lda #13
  jsr ROMPUTA
  lda #10
  jsr ROMPUTA
  rts


startstr:   .byte "xmodem listening", $0d, $0a, $00
recvdstr:   .byte "xmodem received", $0d, $0a, $00
blockerrstr:.byte "block count error", $0a, $0d, $00
chksmerrstr:.byte "checksum errror", $0a, $0d, $00
headerrstr: .byte "header error", $0a, $0d, $00
hextable:   .byte "0123456789ABCDEF"
