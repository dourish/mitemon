;;;
;;; CLS. Clear the screen.
;;;

* = $0300

  jmp start

;;; these variables are imported from the monitor/FORTH
PRINTVEC=$0042
INPUT=$7F00
SCRATCH=$0010
CURSEC=$0068
WORD=$7EC0
LBLOCK=$7C00
HBLOCK=$7D00
IOSENTINEL=$7E00
KILLLINE=$7F80      ; and 7F81
KILLBUFFER=$7F82    ; upper half of FORTH input buffer


VROW=$0A
VCOL=$0B

DLSTOP=0
DLSTART=$80
DRAWSQUARE=$10
FILL=$20

#include "../decl.a65"
#include "../stack.a65"
#include "jmptable.a65"


start

  jsr cls
  jsr home
  stz VCOL
  stz VROW
  rts


home
  ldy #0
  lda #$2a
  jsr ROMWRVREG
  ldy #0
  lda #$2b
  jsr ROMWRVREG
  ldy #0
  lda #$2c
  jsr ROMWRVREG
  lda #$2d
  ldy #0
  jsr ROMWRVREG
  
  rts


;;; also include all the RA8875-specific definitions
#include "spivdefs.a65"

#include "delay.a65"

;;; fill screen with the current foreground color
;;;
fillscreen

  ;; set up parameters -- startx, starty, endx, endy
  lda #$91
  ldy #0
  jsr ROMWRVREG
  ldy #0
  lda #$92
  jsr ROMWRVREG
  ldy #0
  lda #$93
  jsr ROMWRVREG
  ldy #0
  lda #$94
  jsr ROMWRVREG

  lda #$95
  ldy #$1F          ; lower byte for 799
  jsr ROMWRVREG
  lda #$96
  ldy #03           ; upper byte for 799
  jsr ROMWRVREG

  lda #$97
  ldy #$df          ; lower byte for 479
  jsr ROMWRVREG
  lda #$98          
  ldy #$01          ; upper byte for 479
  jsr ROMWRVREG

  lda #DCR
  ldy #DLSTOP|DRAWSQUARE
  jsr ROMWRVREG
  
  lda #DCR
  ldy #DLSTART|FILL|DRAWSQUARE
  jsr ROMWRVREG

  ;; wait until complete
.(
busyloop
  lda #$90
  jsr ROMRDVREG
  bmi busyloop
.)

  rts

;;; draw a filled rectangle, presuming that it's already all set up
fillrect
  lda #DCR
  ldy #DLSTOP|DRAWSQUARE
  jsr ROMWRVREG
  
  lda #DCR
  ldy #DLSTART|FILL|DRAWSQUARE
  jsr ROMWRVREG

  ;; wait until complete
.(
busyloop
  lda #$90
  jsr ROMRDVREG
  bmi busyloop
.)

  rts

;;; set foreground color to values from color table indexed by A
;;;
setfg
  sta SCRATCH       ; cache A then multiply by 3
  asl               ; = *2
  clc
  adc SCRATCH       ; = *3
  sta SCRATCH       ; store it because I can't rely on Y

  ldy SCRATCH       ; load the offset
  lda colors,y      ; load color value at offset
  tay               ; move to Y
  lda #$63          ; register to A
  jsr ROMWRVREG      ; store Y in A
  inc SCRATCH       ; move on to next value

  ldy SCRATCH       ; load the offset
  lda colors,y      ; load color value at offset
  tay               ; move to Y
  lda #$64          ; register to A
  jsr ROMWRVREG      ; store Y in A
  inc SCRATCH       ; move on to next value

  ldy SCRATCH       ; load the offset
  lda colors,y      ; load color value at offset
  tay               ; move to Y
  lda #$65          ; register to A
  jsr ROMWRVREG      ; store Y in A

  rts

colors
  .byte $00, $00, $00    ; black
  .byte $1F, $00, $00    ; red
  .byte $00, $3F, $00    ; green
  .byte $00, $00, $1F    ; blue
  .byte $00, $3F, $1F    ; cyan
  .byte $1F, $00, $1F    ; magenta
  .byte $1F, $3F, $00    ; yellow
  .byte $1F, $3F, $1F    ; white
  .byte $0F, $1F, $0F    ; grey
  .byte $1D, $18, $15    ; pink?


;;; fill the screen with the color from the color table specified in
;;; the accumulator. Set color back to current setting afterwards.
;;;
fillcolor
  sta SCRATCH       ; temporarily store color
  
  ;; look up current color values and save them
  lda #$63
  jsr ROMRDVREG
  pha

  lda #$64
  jsr ROMRDVREG
  pha

  lda #$65
  jsr ROMRDVREG
  pha

  ;; set fg color
  lda SCRATCH
  jsr setfg

  ;; fill screen
  jsr fillscreen
  ;; wait until complete
.(
busyloop
  lda #$90
  jsr ROMRDVREG
  bmi busyloop
.)

  ;; reset color
  pla
  tay
  lda #$65
  jsr ROMWRVREG
  pla
  tay
  lda #$64
  jsr ROMWRVREG
  pla
  tay
  lda #$63
  jsr ROMWRVREG

  rts



;;; clear screen
;;;
cls
  ;; fill the screen with black
  lda #0            ; color 0 is black
  jsr fillcolor

  rts



