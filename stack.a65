;; 16-bit stack stuff

;; Rather like the hadware stack, this stack lives on a dedicated page, and
;; grows downwards. Unlike the regular stack, this one is a 16-bit stack, used
;; for operands and parameters.
;;
;; the stack lives in the top half of the zero page, and grows downward,
;; indexed by the x register (so $80+x indicates the next free byte).
;; $80 and $81 hold the 16-bit value that is either going on to or coming
;; off the stack.
;;
;; since $80,x gives us the next available stack slot, $81,x is the item
;; on the top of the stack
;;
;; We push the big end first, so that the data is on the stack in little-
;; endian format, which means we can do indirect addressing directly
;; through objects on the stack.

stackaccess = $0080
stackbase   = $0080


initstack
  ldx #$FF

push
  lda stackaccess+1          ; first byte (big end)
  sta stackbase,x
  dex
  lda stackaccess            ; second byte (little end)
  sta stackbase,x
  dex
  rts

pop
  lda stackbase+1,x          ; the little end
  sta stackaccess
  inx
  lda stackbase+1,x          ; retrieve second byte
  sta stackaccess+1
  inx
  rts

dup
  lda stackbase+2,x          ; copy big end byte to next available slot
  sta stackbase,x
  dex
  lda stackbase+2,x          ; do again for little end
  sta stackbase,x
  dex
  rts

swap
  // first, do a dup
  lda stackbase+2,x          ; copy big end byte to next available slot
  sta stackbase,x
  dex
  lda stackbase+2,x          ; do again for little end
  sta stackbase,x
  dex
  // stack has now grown by one
  // now copy item from slot 3 to slot 2
  // low end byte is already in accumulator
  lda stackbase+5,x
  sta stackbase+3,x
  lda stackbase+6,x
  sta stackbase+4,x
  // now copy top-of-stack item into slot 3
  lda stackbase+1,x
  sta stackbase+5,x
  lda stackbase+2,x
  sta stackbase+6,x
  // discard temporary value on the top of the stack
  dex
  dex
  rts
  
