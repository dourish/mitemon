;; 16-bit stack stuff

;; Rather like the hadware stack, this stack lives on a dedicated page, and
;; grows downwards. Unlike the regular stack, this one is a 16-bit stack, used
;; for operands and parameters.
;;
;; the stack lives in the top half of the zero page, and grows downward,
;; indexed by the x register (so $80+x indicates the next free byte).
;; $80 and $81 hold the 16-bit value that is either going on to or coming
;; off the stack.
;;
;; since $80,x gives us the next available stack slot, $81,x is the item
;; on the top of the stack
;;
;; We push the big end first, so that the data is on the stack in little-
;; endian format, which means we can do indirect addressing directly
;; through objects on the stack.

stackaccess = $0080
stackbase   = $0000


initstack
  ldx #$FF
  rts

push16
  lda stackaccess+1          ; first byte (big end)
  sta stackbase,x
  dex
  lda stackaccess            ; second byte (little end)
  sta stackbase,x
  dex
  rts

pop16
  lda stackbase+1,x          ; the little end
  sta stackaccess
  inx
  lda stackbase+1,x          ; retrieve second byte
  sta stackaccess+1
  inx
  rts

dup16
  lda stackbase+2,x          ; copy big end byte to next available slot
  sta stackbase,x
  dex
  lda stackbase+2,x          ; do again for little end
  sta stackbase,x
  dex
  rts

swap16
  // first, do a dup
  lda stackbase+2,x          ; copy big end byte to next available slot
  sta stackbase,x
  dex
  lda stackbase+2,x          ; do again for little end
  sta stackbase,x
  dex
  // stack has now grown by one
  // now copy item from slot 3 to slot 2
  // low end byte is already in accumulator
  lda stackbase+5,x
  sta stackbase+3,x
  lda stackbase+6,x
  sta stackbase+4,x
  // now copy top-of-stack item into slot 3
  lda stackbase+1,x
  sta stackbase+5,x
  lda stackbase+2,x
  sta stackbase+6,x
  // discard temporary value on the top of the stack
  inx
  inx
  rts

add16
  clc                        ; clear carry
  lda stackbase+1,x          ; add the lower byte
  adc stackbase+3,x
  sta stackbase+3,x          ; put it back in the second slot
  lda stackbase+2,x          ; then the upper byte
  adc stackbase+4,x
  sta stackbase+4,x          ; again, back in the second slot
  inx                        ; shink the stack so that sum is now
  inx                        ; in the top slot
  rts


;; at the address denoted by the top of the stack, read a two-character
;; string and interpret it as a hex byte, decode, and leave the result
;; on the stack.
;; BUG fails if string crosses page boundary
;;
read8hex
  jsr pop16                ; address into stackaccess (and off stack)
  lda (stackaccess)        ; first nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  asl
  asl
  asl
  asl
  sta SCRATCH+4          ; assembling result here
.)
  inc stackaccess        ; BUG won't work if string crosses a page boundary
  lda (stackaccess)      ; second nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  jmp next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  jmp next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  clc
  adc SCRATCH+4
  sta SCRATCH+4
.)
  sta stackaccess
  stz stackaccess+1
  jsr push16
  rts


;; at the address denoted by the top of the stack, read a four-character
;; string and interpret it as a 16-bit word, decode, and leave the result
;; on the stack.
;; BUG fails if string crosses page boundary
;;
read16hex
  ;;
  ;; here's the logic:
  ;; if char code < 0x40 then subtractand is 0x30
  ;; else if char code < 0x60 then subtractand is 0x37
  ;; else subtractand is 0x57
  ;;

  jsr pop16                ; address into stackaccess (and off stack)
  lda (stackaccess)        ; first nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  asl
  asl
  asl
  asl
  sta SCRATCH+3          ; assembling result here
.)
  inc stackaccess    ; BUG won't work if string crosses page boundary
  lda (stackaccess)      ; second nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  clc
  adc SCRATCH+3
  sta SCRATCH+3
.)
  inc stackaccess        ; BUG see above
  lda (stackaccess)      ; third nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  asl
  asl
  asl
  asl
  sta SCRATCH+2          ; assembling result here (little-endian, so earlier)
.)
  inc stackaccess  ; BUG see above
  lda (stackaccess)      ; fourth nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  clc
  adc SCRATCH+2
  sta SCRATCH+2
.)
  sta stackaccess
  lda SCRATCH+3
  sta stackaccess+1
  jsr push16
  rts


print16hex
  jsr pop16
  lda stackaccess+1
  jsr putax
  lda stackaccess
  jsr putax
  rts

print8hex
  jsr pop16
  lda stackaccess
  jsr putax
  rts

print16dec
  ;; create myself three bytes of storage on the stack
  DEX
  dex
  dex
  
  ;; that leaves the data to be read at stackbase+4,x and stackbase+5,x
  
  stz stackbase+1,x ; dec0
  stz stackbase+2,x ; dec1
  stx stackbase+3,x ; dec2

  ;; temporary storage will be in the SCRATCH area
  lda #0
  sed
  ldy #16

.(
loop
  asl stackbase+4,x
  rol stackbase+5,x
  lda stackbase+1,x
  adc stackbase+1,x
  sta stackbase+1,x
  lda stackbase+2,x
  adc stackbase+2,x
  sta stackbase+2,x
  rol stackbase+3,x
  dey
  bne loop
.)
  cld

  ;; we have the result in the temporary storage, as BCD. now print that as
  ;; a five-character string (since max is 65535).
  ;; could do this using y as an index and looping.. rather than unrolling
  ;; as here

  ;; decimal 2
  ;; mask off lower four bits
  lda stackbase+3,x
  and #%00001111
  clc
  adc #'0
  jsr puta

  ;; decimal 1
  ;; first, upper four bits
  lda stackbase+2,x
  and #%11110000
  clc
  ror
  ror
  ror
  ror
  clc
  adc #'0
  jsr puta

  ;; and then lower four bits
  lda stackbase+2,x
  and #%00001111
  clc
  adc #'0
  jsr puta

  ;; and finally decimal 0
  ;; first, upper four bits
  lda stackbase+1,x
  and #%11110000
  clc
  ror
  ror
  ror
  ror
  clc
  adc #'0
  jsr puta

  ;; and then lower four bits
  lda stackbase+1,x
  and #%00001111
  clc
  adc #'0
  jsr puta

  ;; clean up -- reclaim our temporary space and also pop item from stack
  INX              ; cleaning
  inx
  inx
  inx              ; popping
  INX
  rts
  
  
print8dec
  ;; to be implemented

printstr
  jsr pop16
  phy               ; preserve Y
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda (stackaccess),y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
  jsr crlf
.)
  ply
  rts
