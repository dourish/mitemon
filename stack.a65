;; 16-bit stack stuff

;; Rather like the hadware stack, this stack lives on a dedicated page, and
;; grows downwards. Unlike the regular stack, this one is a 16-bit stack, used
;; for operands and parameters.
;;
;; the stack lives in the top half of the zero page, and grows downward,
;; indexed by the x register (so $80+x indicates the next free byte).
;; $80 and $81 hold the 16-bit value that is either going on to or coming
;; off the stack.
;;
;; since $80,x gives us the next available stack slot, $81,x is the item
;; on the top of the stack
;;
;; We push the big end first, so that the data is on the stack in little-
;; endian format, which means we can do indirect addressing directly
;; through objects on the stack.

stackaccess = $0080
stackbase   = $0000


initstack
  ldx #$FF
  rts

push16
  lda stackaccess+1          ; first byte (big end)
  sta stackbase,x
  dex
  lda stackaccess            ; second byte (little end)
  sta stackbase,x
  dex
  rts

pop16
  lda stackbase+1,x          ; the little end
  sta stackaccess
  inx
  lda stackbase+1,x          ; retrieve second byte
  sta stackaccess+1
  inx
  rts

dup16
  lda stackbase+2,x          ; copy big end byte to next available slot
  sta stackbase,x
  dex
  lda stackbase+2,x          ; do again for little end
  sta stackbase,x
  dex
  rts

swap16
  // first, do a dup
  lda stackbase+2,x          ; copy big end byte to next available slot
  sta stackbase,x
  dex
  lda stackbase+2,x          ; do again for little end
  sta stackbase,x
  dex
  // stack has now grown by one
  // now copy item from slot 3 to slot 2
  // low end byte is already in accumulator
  lda stackbase+5,x
  sta stackbase+3,x
  lda stackbase+6,x
  sta stackbase+4,x
  // now copy top-of-stack item into slot 3
  lda stackbase+1,x
  sta stackbase+5,x
  lda stackbase+2,x
  sta stackbase+6,x
  // discard temporary value on the top of the stack
  inx
  inx
  rts

;; Add the two 16-byte words on the top of the stack, leaving
;; the result on the stack in their place.
add16
  clc                        ; clear carry
  lda stackbase+1,x          ; add the lower byte
  adc stackbase+3,x
  sta stackbase+3,x          ; put it back in the second slot
  lda stackbase+2,x          ; then the upper byte
  adc stackbase+4,x
  sta stackbase+4,x          ; again, back in the second slot
  inx                        ; shink the stack so that sum is now
  inx                        ; in the top slot
  rts

;; Subtract the two 16-byte words on the top of the stack, leaving
;; the result on the stack in their place.
sub16
  sec                        ; set the carry
  lda stackbase+3,x          ; substract the lower byte
  sbc stackbase+1,x
  sta stackbase+3,x          ; put it back in the second slot
  lda stackbase+4,x          ; then the upper byte
  sbc stackbase+2,x
  sta stackbase+4,x          ; again, back in the second slot
  inx                        ; shink the stack so that result is now
  inx                        ; in the top slot
  rts

;; Multiply the two 16-byte words on the top of the stack, leaving
;; the result on the stack in their place.
mult16
.(
  ;; make some temporary space on the stack
  dex
  dex

  ;stz templsb
  ;stz tempmsb
  stz stackbase+1,x
  stz stackbase+2,x

  ;; n1lsb stackbase+3,x
  ;; n1msb stackbase+4,x
  ;; n2lsb stackbase+5,x
  ;; n2msb stackbase+6,x
nextbit
  ; first bit
  lda #$01
  bit stackbase+5,x
  beq nextshift
  ; do addition
  clc
  lda stackbase+3,x
  adc stackbase+1,x
  sta stackbase+1,x
  lda stackbase+4,x
  adc stackbase+2,x
  sta stackbase+2,x
nextshift
  ; shift n1 left
  asl stackbase+3,x
  rol stackbase+4,x
  ; shift n2 right
  clc
  ror stackbase+6,x
  ror stackbase+5,x
  bne nextbit
  lda stackbase+6,x
  bne nextbit
done
.)
  ;; clean up the mess we made on the stack
  ;; first, put the result back in the right place
  lda stackbase+1,x
  sta stackbase+5,x
  lda stackbase+2,x
  sta stackbase+6,x
  ;; then, discard our temporary space
  inx
  inx
  ;; finally, discard multiplicand
  inx
  inx
  rts


;; divide top of stack into second-top of stack, popping both off
;; and leaving quotient in their place
div16
.(
  phy               ; preserve Y

  ;; make some working space on the stack. two 16-bit values needed.
  dex
  dex
  dex
  dex

  ;; zero out those spaces
  stz stackbase+1,x ; stackbase+1 and +2 are remainlsb, remainmsb
  stz stackbase+2,x
  stz stackbase+3,x ; stackbase+3 and +4 are resultlsb, resultmsb
  stz stackbase+4,x

  ; divisor (n1) is stackbase+5 and +6
  ; divisand (n2) is stackbase+7 and +8

  ldy #$10          ; loop count, going 16 times (one per bit)
nextbit
  ; shift n2 (divisand) left, rotating top bit into temp
  asl stackbase+7,x
  rol stackbase+8,x
  rol stackbase+1,x
  rol stackbase+2,x
  ; is temp larger than/equal to n1?
  lda stackbase+2,x       ; msb first -- does that resolve it?
  cmp stackbase+6,x
  bcc shift0
  bne subtract
  lda stackbase+1,x
  cmp stackbase+5,x
  bcs subtract
  bra shift0
  ; yes so subtract n1 from temp
subtract
  sec
  lda stackbase+2,x
  sbc stackbase+6,x
  sta stackbase+2,x
  lda stackbase+1,x
  sbc stackbase+5,x
  sta stackbase+1,x
  ; shift and test
shift1
  ; shift result one place left, shifting in a 1 at the bottom
  sec
  rol stackbase+3,x
  rol stackbase+4,x
  bra test
shift0
  ; shift result one place left, shifting in a 1 at the bottom
  clc
  rol stackbase+3,x
  rol stackbase+4,x
test
  ; test-- are we done (all 16 bits)?
  dey
  bne nextbit
  ;; we are now done.
  ;; remainder is in stackbase+1 and +2; quotient is in stackbase+3 and +4
enddiv
.)
  ;; clean up. start by putting result in the right place
  lda stackbase+3,x
  sta stackbase+7,x
  lda stackbase+4,x
  sta stackbase+8,x

  ;; then reset the stack pouinter, dropping three words (two
  ;; used for working and one used for parameter).
  inx
  inx
  inx
  inx
  inx
  inx

  ply               ; restore y
  rts



;; divide top of stack into second-top of stack, popping both off
;; and leaving remainder in their place
mod16
.(
  phy               ; preserve Y

  ;; make some working space on the stack. two 16-bit values needed.
  dex
  dex
  dex
  dex

  ;; zero out those spaces
  stz stackbase+1,x ; stackbase+1 and +2 are remainlsb, remainmsb
  stz stackbase+2,x
  stz stackbase+3,x ; stackbase+3 and +4 are resultlsb, resultmsb
  stz stackbase+4,x

  ; divisor (n1) is stackbase+5 and +6
  ; divisand (n2) is stackbase+7 and +8

  ldy #$10          ; loop count, going 16 times (one per bit)
nextbit
  ; shift n2 (divisand) left, rotating top bit into temp
  asl stackbase+7,x
  rol stackbase+8,x
  rol stackbase+1,x
  rol stackbase+2,x
  ; is temp larger than/equal to n1?
  lda stackbase+2,x       ; msb first -- does that resolve it?
  cmp stackbase+6,x
  bcc shift0
  bne subtract
  lda stackbase+1,x
  cmp stackbase+5,x
  bcs subtract
  bra shift0
  ; yes so subtract n1 from temp
subtract
  sec
  lda stackbase+2,x
  sbc stackbase+6,x
  sta stackbase+2,x
  lda stackbase+1,x
  sbc stackbase+5,x
  sta stackbase+1,x
  ; shift and test
shift1
  ; shift result one place left, shifting in a 1 at the bottom
  sec
  rol stackbase+3,x
  rol stackbase+4,x
  bra test
shift0
  ; shift result one place left, shifting in a 1 at the bottom
  clc
  rol stackbase+3,x
  rol stackbase+4,x
test
  ; test-- are we done (all 16 bits)?
  dey
  bne nextbit
  ;; we are now done.
  ;; remainder is in stackbase+1 and +2; quotient is in stackbase+3 and +4
enddiv
.)
  ;; clean up. start by putting result in the right place
  lda stackbase+1,x
  sta stackbase+7,x
  lda stackbase+2,x
  sta stackbase+8,x

  ;; then reset the stack pouinter, dropping three words (two
  ;; used for working and one used for parameter).
  inx
  inx
  inx
  inx
  inx
  inx

  ply               ; restore y
  rts

;; at the address denoted by the top of the stack, read a two-character
;; string and interpret it as a hex byte, decode, and leave the result
;; on the stack.
;; BUG fails if string crosses page boundary
;;
read8hex
  jsr pop16                ; address into stackaccess (and off stack)
  lda (stackaccess)        ; first nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  asl
  asl
  asl
  asl
  sta SCRATCH+4          ; assembling result here
.)
  inc stackaccess        ; BUG won't work if string crosses a page boundary
  lda (stackaccess)      ; second nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  jmp next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  jmp next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  clc
  adc SCRATCH+4
  sta SCRATCH+4
.)
  sta stackaccess
  stz stackaccess+1
  jsr push16
  rts


;; at the address denoted by the top of the stack, read a four-character
;; string and interpret it as a 16-bit word, decode, and leave the result
;; on the stack.
;; BUG fails if string crosses page boundary
;;
read16hex
  ;;
  ;; here's the logic:
  ;; if char code < 0x40 then subtractand is 0x30
  ;; else if char code < 0x60 then subtractand is 0x37
  ;; else subtractand is 0x57
  ;;

  jsr pop16                ; address into stackaccess (and off stack)
  lda (stackaccess)        ; first nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  asl
  asl
  asl
  asl
  sta SCRATCH+3          ; assembling result here
.)
  inc stackaccess    ; BUG won't work if string crosses page boundary
  lda (stackaccess)      ; second nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  clc
  adc SCRATCH+3
  sta SCRATCH+3
.)
  inc stackaccess        ; BUG see above
  lda (stackaccess)      ; third nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  asl
  asl
  asl
  asl
  sta SCRATCH+2          ; assembling result here (little-endian, so earlier)
.)
  inc stackaccess  ; BUG see above
  lda (stackaccess)      ; fourth nybble
.(
  cmp #$60
  bcc upper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra next
upper
  cmp #$40
  bcc number
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra next
number
  ;; numeric character, so subtract $30
  sec
  sbc #$30
next
  clc
  adc SCRATCH+2
  sta SCRATCH+2
.)
  sta stackaccess
  lda SCRATCH+3
  sta stackaccess+1
  jsr push16
  rts

;; read a 16-bit number in decimal. need to allow for the fact that
;; there may be a variable number of digits (but presume that
;; there is always one).
;; NOTE changed the label because it was calling the wrong place!
readdec16
  jsr pop16         ; move the string address into stackaccess

  dex               ; make some workspace on the stack. need two 16-byte
  dex               ; words, one of which will eventually be our result
  dex               ; so, workspace space is stackbase+1,x to stackbase+4,x
  dex
  stz stackbase+1,x ; zero out both 16-bit values
  stz stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  phy               ; preserve y
  ldy #0            ; y indexes digits of the input string
nextdigit
  lda (stackaccess),y

  sec
  sbc #$30          ; turn from ascii digit into a number
  clc               ; add it to our partial result
  adc stackbase+3,x
  sta stackbase+3,x
  lda stackbase+4,x
  adc #0
  sta stackbase+4,x
  iny               ; bump the character count
  cpy #5            ; was that the last digit to be read? (max 5)
  beq donelastdigit  
  lda (stackaccess),y
  beq donelastdigit ; stop stop if we hit null-terminator

mult10              ; more digits, so multiply by ten and go around
  asl stackbase+3,x ; shift left to multiply by two
  rol stackbase+4,x

  lda stackbase+3,x ; make a copy in the other temporary slot
  sta stackbase+1,x
  lda stackbase+4,x
  sta stackbase+2,x
  asl stackbase+1,x ; shift the copy left twice more, so x8 in total
  rol stackbase+2,x
  asl stackbase+1,x
  rol stackbase+2,x

  clc               ; add them (8x + 2x = 10x)
  lda stackbase+1,x
  adc stackbase+3,x
  sta stackbase+3,x
  lda stackbase+2,x
  adc stackbase+4,x
  sta stackbase+4,x

  bra nextdigit

donelastdigit
  inx               ; drop one of the temporary variables
  inx               ; but leave the other, which is our result
  ply               ; restore y
  rts



print16hex
  jsr pop16
  lda stackaccess+1
  jsr putax
  lda stackaccess
  jsr putax
  rts

print8hex
  jsr pop16
  lda stackaccess
  jsr putax
  rts

;;; This routine is only called from my Forth, so I've modified it to
;;; suit. Mainly, that means printing a space before the number.
print16dec
  ;; create myself three bytes of storage on the stack
  dex
  dex
  dex
  
  ;; that leaves the data to be read at stackbase+4,x and stackbase+5,x
  
  stz stackbase+1,x ; dec0
  stz stackbase+2,x ; dec1
  stx stackbase+3,x ; dec2

  phy               ; preserve Y
  lda #0
  sed
  ldy #16           ; count of bits we are processing

.(
loop
  asl stackbase+4,x
  rol stackbase+5,x
  lda stackbase+1,x
  adc stackbase+1,x
  sta stackbase+1,x
  lda stackbase+2,x
  adc stackbase+2,x
  sta stackbase+2,x
  rol stackbase+3,x
  dey
  bne loop
.)
  cld

  ;; we have the result in the temporary storage, as BCD. now print that as
  ;; a five-character string (since max is 65535).
  ;; could do this using y as an index and looping.. rather than unrolling
  ;; as here

  ;; set a flag to determine whether we've printed anything non-zero
  stz SCRATCH

  ;; print leading space
  lda #$20
  jsr puta

  ;; decimal 2
  ;; mask off lower four bits
  lda stackbase+3,x
  and #%00001111
  clc
  adc #'0
.(
  cmp #'0
  bne continue      ; not a zero, so proceed to printing
  bit SCRATCH       ; is this a leading zero (have we printed anything?)
  beq dec1up        ; nothing printed yet, so skip this digit
continue
  jsr puta          ; print the digit
.)
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

dec1up
  ;; decimal 1
  ;; first, upper four bits
  lda stackbase+2,x
  and #%11110000
  clc
  ror
  ror
  ror
  ror
  clc
  adc #'0
.(
  cmp #'0
  bne continue      ; not a zero, so proceed to printing
  bit SCRATCH       ; is this a leading zero (have we printed anything?)
  beq dec1low       ; nothing printed yet, so skip this digit
continue
  jsr puta          ; print the digit
.)
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

dec1low
  ;; and then lower four bits
  lda stackbase+2,x
  and #%00001111
  clc
  adc #'0
.(
  cmp #'0
  bne continue      ; not a zero, so proceed to printing
  bit SCRATCH       ; is this a leading zero (have we printed anything?)
  beq dec0up        ; nothing printed yet, so skip this digit
continue
  jsr puta          ; print the digit
.)
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

dec0up
  ;; and finally decimal 0
  ;; first, upper four bits
  lda stackbase+1,x
  and #%11110000
  clc
  ror
  ror
  ror
  ror
  clc
  adc #'0
.(
  cmp #'0
  bne continue      ; not a zero, so proceed to printing
  bit SCRATCH       ; is this a leading zero (have we printed anything?)
  beq dec0low       ; nothing printed yet, so skip this digit
continue
  jsr puta          ; print the digit
.)
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

dec0low
  ;; and then lower four bits -- last digit, so no check for zero
  lda stackbase+1,x
  and #%00001111
  clc
  adc #'0
  jsr puta

  ;; clean up -- reclaim our temporary space and also pop item from stack
  ply              ; restore Y
  inx              ; clean up our three bytes
  inx
  inx
  inx              ; popping (discard result)
  inx              ; second byte
  rts
  
  
print8dec
  ;; to be implemented

printstr
  jsr pop16
  phy               ; preserve Y
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda (stackaccess),y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
  jsr crlf
.)
  ply
  rts
