

;;;
;;; Basic xmodem implementation (receive only)
;;; Super simplistic. So far, this (1) doesn't implement any timeouts, and
;;; (2) bascially presumes that everything goes great or all it all just
;;; konks out... it presumes blocks will keep on going up and that there
;;; will never be re-transmissions, etc. All these are reasonable
;;; assumptions over a USB serial line that's only a couple of feet long.
;;;
;;; Paul Dourish, September 2017
;;;

XBLOCKNO    = $0030
XBLOCKINV   = $0031
XBLOCKCOUNT = $0032
XCHKSUM     = $0033
XDESTADDR   = $0034 ; and $0035
BUFFER      = $0036 ; and $0037



;; entry point
;;
xmodemrecv
  ;; first, print a message announcing that we're listening
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda startstr,y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
  jsr crlf
.)

.(
  phx               ; preserve operand stack pointer

  ; load up the destination location. for the moment, that's just
  ; a test block in memory ($0400)
  ; THIS CODE REMOVED NOW THAT WE'RE GETTING IT FROM PARAMETER
  ;stz XDESTADDR
  ;lda #$04
  ;sta XDESTADDR+1

  ; load up the buffer location. this is purely during test -- don't need
  ; it after
  ; THIS CODE REMOVED NOW THAT WE ARE READING LIVE FROM SERIAL
  ;LDA #<XBUFFER
  ;STA BUFFER
  ;LDA #>XBUFFER
  ;STA BUFFER+1

  stz XBLOCKCOUNT
  ldy #$0
  ldx #0

  ;; okay, now we wait for transmission to start. the deal here is that
  ;; we are meant to listen with 10-second timeouts, and sent a NACK
  ;; every ten seconds, one of which will signal to the other end that
  ;; we are ready to go. However, we don't have a timer set up anywhere.
  ;; so I'm going to cheat -- we will basically listen for 256x256 loops,
  ;; and send an ACK after that. it will actually just be a second or two.
waitstart
  ldy #$0
  ldx #$0
.(
wait_rxd_full    
  inx               ; counting up to 256
  beq bumpy         ; count cycled, so increment Y
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
  jmp gotfirstchar
bumpy
  iny               ; counting up to 256
  beq sendnack      ; Y has cycled, so we've looped 256*256 times
  bra wait_rxd_full  
sendnack
  ;; send a nack
  lda #$15
  jsr puta
  bra wait_rxd_full
.)
gotfirstchar
  ldx #$0           ; reset X and Y
  ldy #$0

nextblock
;; check header data and block number
processbuffer
  jsr getserial     ; get first character (if we don't already have it)
  cmp #$04          ; end-of-transmission?
  beq endoftransmission
  cmp #$01          ; start-of-header?
  beq processblock
  jsr headererror
  jmp xmerror

processblock
  ;; get block number and inverse block number
  jsr getserial
  sta XBLOCKNO
  jsr getserial
  sta XBLOCKINV
  sec
  lda #255
  sbc XBLOCKNO
  cmp XBLOCKINV     ; does block number match inverse block number?
  beq checkblockcount
  jsr blockcounterror
  jmp xmerror

checkblockcount
  inc XBLOCKCOUNT
  lda XBLOCKCOUNT
  cmp XBLOCKNO      ; does it match what we were expecting?
  beq processdata
  jsr blockcounterror
  jmp xmerror

processdata
  stz XCHKSUM
  ldy #0
nextbyte
  jsr getserial
  sta (XDESTADDR),y
  clc
  adc XCHKSUM
  sta XCHKSUM
  iny
  cpy #$80
  bne nextbyte
endofblock
  jsr getserial
  cmp XCHKSUM
  beq checksumok
  jsr putax
  lda XCHKSUM
  jsr putax
  jsr checksumerror
  jmp xmerror
checksumok
  ;; send an ACK
  lda #$06
  jsr puta

  ;; update the destination address by 128 ($80)
  lda #$80
  clc
  adc XDESTADDR
  sta XDESTADDR
  lda XDESTADDR+1
  adc #0
  sta XDESTADDR+1
  ;; and loop for next block

  bra nextblock

;; Send an ACK. Pause briefly to allow the connection to be torn down.
;; Then print a message to signal successful completion.
endoftransmission
  ;; send an ACK
  lda #$06
  jsr puta

.(
  ;; this is just to generate a pause. entirely arbitrary.
  ;;
  lda #$10
fullloop
  ldy #$0
busywait
  iny
  bne busywait
  dec
  bne fullloop
.)  

  jsr crlf
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda recvdstr,y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
  jsr crlf
.)
  jmp endxmodem

xmerror

endxmodem
  plx               ; restore operand stack pointer in x
  rts
.)


;; get a character from the serial port
;;
getserial
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA
  rts


;; test data
XBUFFER
.byte $01, $01, $FE
.byte $54,  $68,  $65,  $20,  $63,  $68,  $69,  $65,  $66,  $20
.byte $64,  $65,  $66,  $65,  $63,  $74,  $20,  $6f,  $66,  $20,  $48,  $65,  $6e,  $72,  $79,  $20
.byte $4b,  $69,  $6e,  $67,  $0a,  $77,  $61,  $73,  $20,  $63,  $68,  $65,  $77,  $69,  $6e,  $67
.byte $20,  $6c,  $69,  $74,  $74,  $6c,  $65,  $20,  $62,  $69,  $74,  $73,  $20,  $6f,  $66,  $20
.byte $73,  $74,  $72,  $69,  $6e,  $67,  $2e,  $0a,  $41,  $74,  $20,  $6c,  $61,  $73,  $74,  $20
.byte $68,  $65,  $20,  $73,  $77,  $61,  $6c,  $6c,  $6f,  $77,  $65,  $64,  $20,  $73,  $6f,  $6d
.byte $65,  $2c,  $20,  $77,  $68,  $69,  $63,  $68,  $20,  $74,  $69,  $65,  $64,  $0a,  $69,  $74
.byte $73,  $65,  $6c,  $66,  $20,  $69,  $6e,  $20,  $6c,  $69,  $74,  $74,  $6c,  $65,  $20,  $6b
.byte $6e,  $6f,  $74,  $73,  $20,  $0a
.byte $5d

.byte $01, $02, $FD
.byte $69,  $6e,  $73,  $69,  $64,  $65,  $2e,  $0a,  $50,  $68,  $79,  $73,  $69,  $63,  $69
.byte $61,  $6e,  $73,  $20,  $6f,  $66,  $20,  $74,  $68,  $65,  $20,  $75,  $74,  $6d,  $6f,  $73
.byte $74,  $20,  $66,  $61,  $6d,  $65,  $0a,  $77,  $65,  $72,  $65,  $20,  $63,  $61,  $6c,  $6c
.byte $65,  $64,  $20,  $61,  $74,  $20,  $6f,  $6e,  $63,  $65,  $2c,  $20,  $62,  $75,  $74,  $20
.byte $77,  $68,  $65,  $6e,  $20,  $74,  $68,  $65,  $79,  $20,  $63,  $61,  $6d,  $65,  $2c,  $0a
.byte $74,  $68,  $65,  $79,  $20,  $61,  $6e,  $73,  $77,  $65,  $72,  $65,  $64,  $2c,  $20,  $61
.byte $73,  $20,  $74,  $68,  $65,  $79,  $20,  $74,  $6f,  $6f,  $6b,  $20,  $74,  $68,  $65,  $69
.byte $72,  $20,  $66,  $65,  $65,  $73,  $2c,  $0a,  $22,  $54,  $68,  $65,  $72,  $65,  $20,  $69
.byte $0a
.byte $c1,

.byte $01, $03, $FC
.byte $73,  $20,  $6e,  $6f
.byte $20,  $63,  $75,  $72,  $65,  $20,  $66,  $6f,  $72,  $20,  $74,  $68,  $69,  $73,  $20,  $64
.byte $69,  $73,  $65,  $61,  $73,  $65,  $2e,  $0a,  $48,  $65,  $6e,  $72,  $79,  $20,  $77,  $69
.byte $6c,  $6c,  $20,  $76,  $65,  $72,  $79,  $20,  $73,  $6f,  $6f,  $6e,  $20,  $62,  $65,  $20
.byte $64,  $65,  $61,  $64,  $2e,  $22,  $0a,  $48,  $69,  $73,  $20,  $70,  $61,  $72,  $65,  $6e
.byte $74,  $73,  $20,  $73,  $74,  $6f,  $6f,  $64,  $20,  $61,  $62,  $6f,  $75,  $74,  $20,  $68
.byte $69,  $73,  $20,  $62,  $65,  $64,  $0a,  $6c,  $61,  $6d,  $65,  $6e,  $74,  $69,  $6e,  $67
.byte $20,  $68,  $69,  $73,  $20,  $75,  $6e,  $74,  $69,  $6d,  $65,  $6c,  $79,  $20,  $64,  $65
.byte $61,  $74,  $68,  $0a,  $77,  $68,  $65,  $6e,  $20,  $48,  $65,  $0a
.byte $37

.byte $01
.byte $04
.byte $FB

.byte $6e,  $72,  $79,  $2c,  $20,  $77,  $69,  $74,  $68
.byte $20,  $68,  $69,  $73,  $20,  $6c,  $61,  $74,  $65,  $73,  $74,  $20,  $62,  $72,  $65,  $61
.byte $74,  $68,  $2c,  $0a,  $63,  $72,  $69,  $65,  $64,  $2c,  $20,  $22,  $4f,  $68,  $20,  $6d
.byte $79,  $20,  $66,  $72,  $69,  $65,  $6e,  $64,  $73,  $2c,  $20,  $62,  $65,  $20,  $77,  $61
.byte $72,  $6e,  $65,  $64,  $20,  $62,  $79,  $20,  $6d,  $65,  $0a,  $74,  $68,  $61,  $74,  $20
.byte $62,  $72,  $65,  $61,  $6b,  $66,  $61,  $73,  $74,  $2c,  $20,  $64,  $69,  $6e,  $6e,  $65
.byte $72,  $2c,  $20,  $6c,  $75,  $6e,  $63,  $68,  $2c,  $20,  $61,  $6e,  $64,  $20,  $74,  $65
.byte $61,  $0a,  $69,  $73,  $20,  $61,  $6c,  $6c,  $20,  $74,  $68,  $65,  $20,  $68,  $75,  $6d
.byte $61,  $6e,  $20,  $66,  $72,  $61,  $0a
.byte $f1,

.byte $01, $05, $FA,
.byte $6d,  $65,  $20,  $72,  $65,  $71,  $75,  $69,  $72,  $65,  $73,  $21,  $22,  $0a
.byte $57,  $69,  $74,  $68,  $20,  $74,  $68,  $61,  $74,  $2c,  $20,  $74,  $68,  $65,  $20,  $77
.byte $72,  $65,  $74,  $63,  $68,  $65,  $64,  $20,  $63,  $68,  $69,  $6c,  $64,  $20,  $65,  $78
.byte $70,  $69,  $72,  $65,  $73,  $2e,  $0a,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58
.byte $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58
.byte $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58
.byte $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58
.byte $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58,  $58
.byte $58,  $0a
.byte $15

.byte $04

checksumerror
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda chksmerrstr,y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
  jsr crlf
.)
  rts

headererror
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda headerrstr,y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
  jsr crlf
.)
  rts

blockcounterror
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda blockerrstr,y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
  jsr crlf
.)
  rts


startstr:   .byte "xmodem listening", $00
recvdstr:   .byte "xmodem received", $00
blockerrstr:.byte "block count error", $00
chksmerrstr:.byte "checksum errror", $00
headerrstr: .byte "header error", $00
